{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TipsTaBet # Web dedicada a la documentaci\u00f3n de todos los procesos realizados durante el proyecto. Dentro de este proyecto se han trabajado los contenidos referentes a las siguientes asignaturas: Fundamentos de Hardware Implantaci\u00f3n de Sistemas Operativos Planificaci\u00f3n y Administraci\u00f3n de Redes Gesti\u00f3n de Bases de Datos Lenguaje de Marcas y Sistemas de Gesti\u00f3n de Informaci\u00f3n","title":"Home"},{"location":"#tipstabet","text":"Web dedicada a la documentaci\u00f3n de todos los procesos realizados durante el proyecto. Dentro de este proyecto se han trabajado los contenidos referentes a las siguientes asignaturas: Fundamentos de Hardware Implantaci\u00f3n de Sistemas Operativos Planificaci\u00f3n y Administraci\u00f3n de Redes Gesti\u00f3n de Bases de Datos Lenguaje de Marcas y Sistemas de Gesti\u00f3n de Informaci\u00f3n","title":"TipsTaBet"},{"location":"Hardware/Fichas-tecnicas/","text":"Hardware # Introducci\u00f3n # Se han elaborado fichas t\u00e9cnicas para conocer el hardware utilizado en el proyecto de los diferentes equipos f\u00edsicos dispuestos. A pesar de que el montaje de los equipos se ha realizado componente a componente, se han utilizado varias herramientas espec\u00edficas para conocer de forma detallada los componentes utilizados. Para evitar tener que instalar aplicaciones en los equipos y disponer de estas herramientas en todo momento, se ha utilizado su versi\u00f3n portable en un usb. En la web lupopensuite.com podemos encontrar much\u00edsimas herramientas portables. Las herramientas utilizadas han sido: HWinfo CPU-Z El NAS utilizado para el proyecto cuenta con el Sistema Operativo Rockstor, basado en CentOS , por lo que se ha utilizado una herramienta de l\u00ednea de comandos, lshw . No viene instalada por defecto, por lo que para su instalaci\u00f3n se ejecutar\u00e1 el comando yum install lshw . Una vez instalada para la consulta de los componentes del equipo ser\u00e1 suficiente ejecutar lshw . Fichas t\u00e9cnicas # A continuaci\u00f3n se dispondr\u00e1 un enlace directo a las fichas t\u00e9cnicas de los diferentes equipos en formato PDF . Windows Server PDC Windows Server SDC Cliente Windows - CentOS Cliente Windows Port\u00e1til NAS Rockstor Resumen # IP Memoria RAM HD Procesador SO Funci\u00f3n 172.16.43.221 4GB 2 HDD en RAID 1 capacidad total: 500GB AMD Athlon 64 X2 Dual Core Processor 3800+, 2009 Mhz Windows Server RAID Controlador de Dominio Principal 172.16.43.222 4GB 1 HDD 500GB AMD Phenom II X4 955 Processor , 3200 Mhz Windows Server Controlador de Dominio Secundario 172.16.43.223 1GB 1 HDD 150GB Intel Atom N450 Windows 10 y Centos Cliente 1 (Port\u00e1til) 172.16.43.224 2GB 1HDD 320GB AMD Sempron 140 Windows 10 y Centos Cliente 2 172.16.43.225 2GB 1HDD 320GB AMD Sempron 140 Windows 10 Cliente 3 172.16.43.226 2GB 1HDD300GB + 1 HDD 75GB AMD Sempron 140 Rockstor NAS 172.16.44.248 1GB 1SD 16GB ARM Cortex-A53 Centos Raspberry \u2013 Servidor web 172.16.44.249 2GB 40GB Virtual Virtual Ubuntu MOODLE 172.16.44.231 4GB 50GB Virtual Virtual Windows Server Controlador de dominio adicional (M\u00e1quina virtual ESXI)","title":"Fichas t\u00e9cnicas"},{"location":"Hardware/Fichas-tecnicas/#hardware","text":"","title":"Hardware"},{"location":"Hardware/Fichas-tecnicas/#introduccion","text":"Se han elaborado fichas t\u00e9cnicas para conocer el hardware utilizado en el proyecto de los diferentes equipos f\u00edsicos dispuestos. A pesar de que el montaje de los equipos se ha realizado componente a componente, se han utilizado varias herramientas espec\u00edficas para conocer de forma detallada los componentes utilizados. Para evitar tener que instalar aplicaciones en los equipos y disponer de estas herramientas en todo momento, se ha utilizado su versi\u00f3n portable en un usb. En la web lupopensuite.com podemos encontrar much\u00edsimas herramientas portables. Las herramientas utilizadas han sido: HWinfo CPU-Z El NAS utilizado para el proyecto cuenta con el Sistema Operativo Rockstor, basado en CentOS , por lo que se ha utilizado una herramienta de l\u00ednea de comandos, lshw . No viene instalada por defecto, por lo que para su instalaci\u00f3n se ejecutar\u00e1 el comando yum install lshw . Una vez instalada para la consulta de los componentes del equipo ser\u00e1 suficiente ejecutar lshw .","title":"Introducci\u00f3n"},{"location":"Hardware/Fichas-tecnicas/#fichas-tecnicas","text":"A continuaci\u00f3n se dispondr\u00e1 un enlace directo a las fichas t\u00e9cnicas de los diferentes equipos en formato PDF . Windows Server PDC Windows Server SDC Cliente Windows - CentOS Cliente Windows Port\u00e1til NAS Rockstor","title":"Fichas t\u00e9cnicas"},{"location":"Hardware/Fichas-tecnicas/#resumen","text":"IP Memoria RAM HD Procesador SO Funci\u00f3n 172.16.43.221 4GB 2 HDD en RAID 1 capacidad total: 500GB AMD Athlon 64 X2 Dual Core Processor 3800+, 2009 Mhz Windows Server RAID Controlador de Dominio Principal 172.16.43.222 4GB 1 HDD 500GB AMD Phenom II X4 955 Processor , 3200 Mhz Windows Server Controlador de Dominio Secundario 172.16.43.223 1GB 1 HDD 150GB Intel Atom N450 Windows 10 y Centos Cliente 1 (Port\u00e1til) 172.16.43.224 2GB 1HDD 320GB AMD Sempron 140 Windows 10 y Centos Cliente 2 172.16.43.225 2GB 1HDD 320GB AMD Sempron 140 Windows 10 Cliente 3 172.16.43.226 2GB 1HDD300GB + 1 HDD 75GB AMD Sempron 140 Rockstor NAS 172.16.44.248 1GB 1SD 16GB ARM Cortex-A53 Centos Raspberry \u2013 Servidor web 172.16.44.249 2GB 40GB Virtual Virtual Ubuntu MOODLE 172.16.44.231 4GB 50GB Virtual Virtual Windows Server Controlador de dominio adicional (M\u00e1quina virtual ESXI)","title":"Resumen"},{"location":"Hardware/Log/","text":"Log acceso servidor Web # En este apartado veremos como obtener las direcciones IP (sin repeticiones) de las diferentes conexiones que recibe el servidor web. Para llevar a cabo esto utilizaremos un script sencillo que se explicar\u00e1 en el siguiente apartado. Note Es interesante que cada vez que se descubra una direcci\u00f3n IP diferente a la que se encuentra en el fichero destino, se notifique al administrador. Una forma de hacerlo es utilizando el comando mail . Script # El script que utilizaremos ser\u00e1 el siguiente. Incluye comentarios para explicar cual es el proceso que sigue el script. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #Declaramos la variable para el fichero donde se encuentra el log de acceso ficherolog = '/var/log/nginx/access.log' #Cortamos la parte de la ip de la l\u00ednea del fichero log lineafichero = ` cut -d ' ' -f 1 $ficherolog ` #Declaramos la variable con el fichero donde almacenaremos las direcciones IP que han accedido al servidor web ficherodestino = '/root/IPs' #Utilizamos la funci\u00f3n \"for\" para comprobar l\u00ednea a l\u00ednea si la direcci\u00f3n ip ya se encuentra en el fichero for i in $lineafichero ; do linea = ` echo $i ` #Buscamos la l\u00ednea en el fichero destino. grep $linea $ficherodestino #Introducimos la funci\u00f3n \"if\" para comprobar si la direcci\u00f3n IP no se encuentra en el fichero destino. En el caso de que no se encuentre se a\u00f1adir\u00e1 al fichero. if [ $? -eq 1 ] ; then echo ` date | cut -d ' ' -f 1 -3 ` $i >> $ficherodestino fi done Note El script se puede descargar pulsando aqu\u00ed . Ejecuci\u00f3n diaria # Es necesario que el script se ejecute diariamente a las 09:00 de la ma\u00f1ana, por lo tanto deberemos utilizar cron para ellos. El funcionamiento del mismo se ha explicado en el apartado Cron del Proyecto Celulosa . 1 2 3 4 #A\u00f1adimos el script a crontab. crontab -e 0 9 * * * sh /root/script.sh","title":"Control de acceso"},{"location":"Hardware/Log/#log-acceso-servidor-web","text":"En este apartado veremos como obtener las direcciones IP (sin repeticiones) de las diferentes conexiones que recibe el servidor web. Para llevar a cabo esto utilizaremos un script sencillo que se explicar\u00e1 en el siguiente apartado. Note Es interesante que cada vez que se descubra una direcci\u00f3n IP diferente a la que se encuentra en el fichero destino, se notifique al administrador. Una forma de hacerlo es utilizando el comando mail .","title":"Log acceso servidor Web"},{"location":"Hardware/Log/#script","text":"El script que utilizaremos ser\u00e1 el siguiente. Incluye comentarios para explicar cual es el proceso que sigue el script. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #Declaramos la variable para el fichero donde se encuentra el log de acceso ficherolog = '/var/log/nginx/access.log' #Cortamos la parte de la ip de la l\u00ednea del fichero log lineafichero = ` cut -d ' ' -f 1 $ficherolog ` #Declaramos la variable con el fichero donde almacenaremos las direcciones IP que han accedido al servidor web ficherodestino = '/root/IPs' #Utilizamos la funci\u00f3n \"for\" para comprobar l\u00ednea a l\u00ednea si la direcci\u00f3n ip ya se encuentra en el fichero for i in $lineafichero ; do linea = ` echo $i ` #Buscamos la l\u00ednea en el fichero destino. grep $linea $ficherodestino #Introducimos la funci\u00f3n \"if\" para comprobar si la direcci\u00f3n IP no se encuentra en el fichero destino. En el caso de que no se encuentre se a\u00f1adir\u00e1 al fichero. if [ $? -eq 1 ] ; then echo ` date | cut -d ' ' -f 1 -3 ` $i >> $ficherodestino fi done Note El script se puede descargar pulsando aqu\u00ed .","title":"Script"},{"location":"Hardware/Log/#ejecucion-diaria","text":"Es necesario que el script se ejecute diariamente a las 09:00 de la ma\u00f1ana, por lo tanto deberemos utilizar cron para ellos. El funcionamiento del mismo se ha explicado en el apartado Cron del Proyecto Celulosa . 1 2 3 4 #A\u00f1adimos el script a crontab. crontab -e 0 9 * * * sh /root/script.sh","title":"Ejecuci\u00f3n diaria"},{"location":"Hardware/Proyecto-Celulosa/","text":"Proyecto Celulosa # En el laboratorio del centro se pretende grabar la evoluci\u00f3n de una bacteria relacionada con la Celulosa. Para ello el grupo de sistemas (Administraci\u00f3n de Sistemas Inform\u00e1ticos en red) configurar\u00e1 una Raspberry pi con una c\u00e1mara conectada para que tome dos fotos por minuto . El vaso que contiene la bacteria y la c\u00e1mara se introducir\u00e1n en un horno a una temperatura de 30\u00baC. Hardware # En este apartado vamos a dejar una tabla para exponer brevemente cual ha sido el material utilizado para llevar a cabo este proyecto. Producto Precio Rasbperry pi 3b+ 37,50\u20ac Tarjeta MicroSD 11,14\u20ac Fuente de alimentaci\u00f3n 9,39\u20ac C\u00e1mara 5 megap\u00edxeles 16,99\u20ac TOTAL 75,02\u20ac Note Los precios de la tabla han sido consultados a fecha 09/05/2019. Puesta en marcha # Para el proyecto hemos utilizado como Sistema Operativo CentOS minimal que podemos descargarnos desde este enlace . Por el momento \u00fanicamente tenemos disponible la versi\u00f3n de 32 bits, que ser\u00e1 con la que trabajaremos en este proyecto. Puesto que la Raspberry pi 3b+ es un dispositivo utilizado en diferentes partes del proyecto, hay otro apartado en el que se explican las primeras configuraciones necesarias para su correcto funcionamiento. Los pasos que se exponen a continuaci\u00f3n hacen referencia a este proyecto en particular, que ser\u00e1 la puesta en marcha del servidor y cliente NFS , los scripts que hemos creado y la configuraci\u00f3n de Cron . Nginx # Partimos de tener el servidor nginx instalado en nuestro sistema. Como pretendemos que las fotograf\u00edas sean accesibles desde un navegador, en servidores nginx se debe hacer una modificaci\u00f3n en el fichero nginx.conf que se encuentra en /etc/nginx/nginx.conf para que indexe el contenido. Adem\u00e1s debemos ajustar la hora para que se ajuste a la hora local de la m\u00e1quina. Debemos a\u00f1adir los siguiente: 1 2 3 4 5 #El directorio Fotos ser\u00e1 el que contendr\u00e1 todas las fotograf\u00edas que va capturan la raspberry. Hay que tener en cuenta que este directorio debe encontrarse en \"\"/usr/share/nginx/html/\". location /Fotos { autoindex on ; autoindex_localtime on ; } Fuente: Linuxito.com NFS Service # Haremos uso del NAS Rockstor como almacenamiento de las fotograf\u00edas que se publicar\u00e1n. Necesitamos almacenamiento externo puesto que obtendremos una fotograf\u00eda cada treinta segundos, y el almacenamiento interno de la Raspberry pi (Tarjeta MicroSD de 16GB) no tiene capacidad suficiente para guardar las fotograf\u00edas que vayamos a sacar durante los cuatro d\u00edas que dura el proyecto. Para acceder a este recurso de red utilizaremos el servicio NFS . En primer lugar al igual que hemos hecho en otras ocasiones para compartir recursos en samba, debemos crear un directorio compartido o Share (as\u00ed lo denomina Rockstor). Este recurso compartido que hemos creado, para que sea accesible desde nuestra Raspberry debemos modificar los permisos y otorgar lectura, escritura y ejecuci\u00f3n a todos los usuarios. Warning Estamos en un proyecto en una red local en la que no tenemos en cuenta la exposici\u00f3n del servidor NFS. Para m\u00e1s informaci\u00f3n sobre la seguridad en servidores NFS consultar el siguiente enlace . Una vez que hemos creado un recurso para compartir, necesitamos habilitar el servicio NFS, encontraremos este servicio en File Sharing dentro de Storage . La configuraci\u00f3n debe de quedar del siguiente modo: Ya tenemos configudo el servidor NFS en nuestro NAS Rockstor, por lo tanto pasamos a configurar el cliente en nuestra Raspberry pi. En primer lugar debemos instalar los paquetes necesario para que el cliente funcione correctamente. Los paquetes a instalar son: nfs-common portmap (para la versi\u00f3n 4 de NFS no es necesario instalar este paquete, m\u00e1s informaci\u00f3n aqu\u00ed ) 1 yum install nfs-common portmap Una vez que tenemos el cliente instalado procedemos a describir los pasos necesarios para montar el recurso en nuestra Rpi. Comprobar que recursos se encuentran disponibles con el comando showmount : 1 showmount -e 172 .16.43.226 Montaje del recurso en la ruta que corresponde. En nuestro hemos montado el recurso en el directorio que utiliza nginx para almacenar el contenido que sirve, es decir en el directorio /usr/share/nginx/html : 1 mount -t nfs ip_del_servidor:/ruta_recurso_compartido /ruta_montaje Para terminar, configuraremos el recurso para que sea montado al inicio del sistema. Para ello es necesario configurar el fichero /etc/fstab : 1 172 .16.90.230:/export/Raspberry /usr/share/nginx/html nfs defaults 0 0 \u200b Los par\u00e1metros descritos en el fichero fstab son los siguientes: Defaults : asigna las opciones de montaje predeterminadas. Estas opciones son: rw , suid , dev , exec , auto , nouser y async . Dump : indica si es necesario realizar una copia de seguirdad del sistema de ficheros. Puesto que no tenemos dump instalado en nuestro sistema debemos establecer 0. Pass : utilizado por fsck para decidir el orden de comprobaci\u00f3n de los sistemas de ficheros. No queremos que realice ninguna comprobaci\u00f3n por lo que le indicamos 0. Fuente: Wiki Archlinux Scripts # En este apartado explicaremos los scripts que se han realizado para diferentes trabajos que queremos que realice la Raspberry. Este primer script tomar\u00e1 una fotograf\u00eda cada 30 segundos . Utilizaremos cron para que ejecute dicho script cada minuto, por lo tanto obtendremos fotograf\u00edas cada 30 segundos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash #Establecemos el nombre que daremos al documento. FECHA = $( date | tr -s ' ' '-' | cut -d '-' -f 1 -4 ) #Ejecutamos el comando para tomar la fotograf\u00eda. raspistill -o /usr/share/nginx/html/Fotos/ $FECHA .jpg #Pausamos el script durante 30 segundos. sleep 30s #Volvemos a generar la variable, si no tomar\u00eda el mismo nombre que el fichero anterior. FECHA = $( date | tr -s ' ' '-' | cut -d '-' -f 1 -4 ) #Ejecutamos de nuevo el comando para tomar la fotograf\u00eda. raspistill -o /usr/share/nginx/html/Fotos/ $FECHA .jpg En este segundo script lo que pretendemos es almacenar las fotograf\u00edas que se realizan durante una hora en un directorio. Este directorio tomar\u00e1 como nombre la fecha y hora de las fotograf\u00edas que se realicen durante una hora completa. Es decir las fotograf\u00edas que se realicen entre las 17:00 y las 18:00 se almacenar\u00e1n en un directorio con el nombre Wed-May-8-17:00/. 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash for i in /usr/share/nginx/html/Fotos/*.jpg do DIRECTORY = $( basename $i | tr -s ':' '-' | cut -d '-' -f 1 -4 ) \\: 00 if [ ! -d /usr/share/nginx/html/Fotos/ $DIRECTORY ] ; then mkdir /usr/share/nginx/html/Fotos/ $DIRECTORY mv $i /usr/share/nginx/html/Fotos/ $DIRECTORY / else mv $i /usr/share/nginx/html/Fotos/ $DIRECTORY / fi done Por \u00faltimo, este script tiene una funci\u00f3n similar al anterior. Lo que pretendemos es que todos los directorios que se hayan creado durante un d\u00eda se almacenen en otro que llevar\u00e1 como nombre la fecha (sin hora). Siguiendo con el ejemplo del script anterior, todos los directorios que se hubiesen creado durante ese d\u00eda se almacenar\u00eda en otro con el nombre Wed-May-8. 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash for i in /usr/share/nginx/html/Fotos/*00 do DIRECTORY = $( basename $i | tr -s ':' '-' | cut -d '-' -f 1 -3 ) if [ ! -d /usr/share/nginx/html/Fotos/ $DIRECTORY ] ; then mkdir /usr/share/nginx/html/Fotos/ $DIRECTORY mv $i /usr/share/nginx/html/Fotos/ $DIRECTORY / else mv $i /usr/share/nginx/html/Fotos/ $DIRECTORY fi done Cron # Para que los scripts que hemos creado en el apartado anterior se ejecuten autom\u00e1ticamente en el horario que nosotros decidamos es necesario hacer uso de el servicio cron . Su uso es muy sencillo, \u00fanicamente es necesario conocer la sintaxis, que podemos consultarla en el fichero /etc/crontab . Para modificar el fichero que lee el servicio cron debemos ejecutar crontab -e , el cual abrir\u00e1 el editor de texto vi para insertar las l\u00edneas que deseemos. En nuestro caso insertaremos tres l\u00edneas, una por cada script que deseamos ejecutar. 1 2 3 4 5 6 #Ejecuci\u00f3n cada minuto */1 * * * * /root/fotos.sh #Ejecuci\u00f3n una vez cada hora @hourly /root/mover.sh #Ejecuci\u00f3n una vez al d\u00eda @daily /root/moverdirectorios.sh En la siguiente tabla extra\u00edda de la wiki de Ubuntu podemos ver otra forma de sintaxis m\u00e1s reducida. Cadena Significado @reboot Se ejecuta una vez, al inicio del sistema. @yearly Se ejecuta una vez al a\u00f1o \"0 0 1 1 *\" @annually Igual que @yearly. @monthly Se ejecuta una vez al mes \"0 0 1 * *\". @weekly Se ejecuta una vez por semana \"0 0 * * 0\". @daily Se ejecuta una vez al d\u00eda \"0 0 * \". @midnight Igual que @daily. @hourly Se ejecuta una vez por hora \"0 * * \". Resultado final # El resultado final es el siguiente: Enlaces de inter\u00e9s # How to Setup NFS Raspistill","title":"Proyecto Celulosa"},{"location":"Hardware/Proyecto-Celulosa/#proyecto-celulosa","text":"En el laboratorio del centro se pretende grabar la evoluci\u00f3n de una bacteria relacionada con la Celulosa. Para ello el grupo de sistemas (Administraci\u00f3n de Sistemas Inform\u00e1ticos en red) configurar\u00e1 una Raspberry pi con una c\u00e1mara conectada para que tome dos fotos por minuto . El vaso que contiene la bacteria y la c\u00e1mara se introducir\u00e1n en un horno a una temperatura de 30\u00baC.","title":"Proyecto Celulosa"},{"location":"Hardware/Proyecto-Celulosa/#hardware","text":"En este apartado vamos a dejar una tabla para exponer brevemente cual ha sido el material utilizado para llevar a cabo este proyecto. Producto Precio Rasbperry pi 3b+ 37,50\u20ac Tarjeta MicroSD 11,14\u20ac Fuente de alimentaci\u00f3n 9,39\u20ac C\u00e1mara 5 megap\u00edxeles 16,99\u20ac TOTAL 75,02\u20ac Note Los precios de la tabla han sido consultados a fecha 09/05/2019.","title":"Hardware"},{"location":"Hardware/Proyecto-Celulosa/#puesta-en-marcha","text":"Para el proyecto hemos utilizado como Sistema Operativo CentOS minimal que podemos descargarnos desde este enlace . Por el momento \u00fanicamente tenemos disponible la versi\u00f3n de 32 bits, que ser\u00e1 con la que trabajaremos en este proyecto. Puesto que la Raspberry pi 3b+ es un dispositivo utilizado en diferentes partes del proyecto, hay otro apartado en el que se explican las primeras configuraciones necesarias para su correcto funcionamiento. Los pasos que se exponen a continuaci\u00f3n hacen referencia a este proyecto en particular, que ser\u00e1 la puesta en marcha del servidor y cliente NFS , los scripts que hemos creado y la configuraci\u00f3n de Cron .","title":"Puesta en marcha"},{"location":"Hardware/Proyecto-Celulosa/#nginx","text":"Partimos de tener el servidor nginx instalado en nuestro sistema. Como pretendemos que las fotograf\u00edas sean accesibles desde un navegador, en servidores nginx se debe hacer una modificaci\u00f3n en el fichero nginx.conf que se encuentra en /etc/nginx/nginx.conf para que indexe el contenido. Adem\u00e1s debemos ajustar la hora para que se ajuste a la hora local de la m\u00e1quina. Debemos a\u00f1adir los siguiente: 1 2 3 4 5 #El directorio Fotos ser\u00e1 el que contendr\u00e1 todas las fotograf\u00edas que va capturan la raspberry. Hay que tener en cuenta que este directorio debe encontrarse en \"\"/usr/share/nginx/html/\". location /Fotos { autoindex on ; autoindex_localtime on ; } Fuente: Linuxito.com","title":"Nginx"},{"location":"Hardware/Proyecto-Celulosa/#nfs-service","text":"Haremos uso del NAS Rockstor como almacenamiento de las fotograf\u00edas que se publicar\u00e1n. Necesitamos almacenamiento externo puesto que obtendremos una fotograf\u00eda cada treinta segundos, y el almacenamiento interno de la Raspberry pi (Tarjeta MicroSD de 16GB) no tiene capacidad suficiente para guardar las fotograf\u00edas que vayamos a sacar durante los cuatro d\u00edas que dura el proyecto. Para acceder a este recurso de red utilizaremos el servicio NFS . En primer lugar al igual que hemos hecho en otras ocasiones para compartir recursos en samba, debemos crear un directorio compartido o Share (as\u00ed lo denomina Rockstor). Este recurso compartido que hemos creado, para que sea accesible desde nuestra Raspberry debemos modificar los permisos y otorgar lectura, escritura y ejecuci\u00f3n a todos los usuarios. Warning Estamos en un proyecto en una red local en la que no tenemos en cuenta la exposici\u00f3n del servidor NFS. Para m\u00e1s informaci\u00f3n sobre la seguridad en servidores NFS consultar el siguiente enlace . Una vez que hemos creado un recurso para compartir, necesitamos habilitar el servicio NFS, encontraremos este servicio en File Sharing dentro de Storage . La configuraci\u00f3n debe de quedar del siguiente modo: Ya tenemos configudo el servidor NFS en nuestro NAS Rockstor, por lo tanto pasamos a configurar el cliente en nuestra Raspberry pi. En primer lugar debemos instalar los paquetes necesario para que el cliente funcione correctamente. Los paquetes a instalar son: nfs-common portmap (para la versi\u00f3n 4 de NFS no es necesario instalar este paquete, m\u00e1s informaci\u00f3n aqu\u00ed ) 1 yum install nfs-common portmap Una vez que tenemos el cliente instalado procedemos a describir los pasos necesarios para montar el recurso en nuestra Rpi. Comprobar que recursos se encuentran disponibles con el comando showmount : 1 showmount -e 172 .16.43.226 Montaje del recurso en la ruta que corresponde. En nuestro hemos montado el recurso en el directorio que utiliza nginx para almacenar el contenido que sirve, es decir en el directorio /usr/share/nginx/html : 1 mount -t nfs ip_del_servidor:/ruta_recurso_compartido /ruta_montaje Para terminar, configuraremos el recurso para que sea montado al inicio del sistema. Para ello es necesario configurar el fichero /etc/fstab : 1 172 .16.90.230:/export/Raspberry /usr/share/nginx/html nfs defaults 0 0 \u200b Los par\u00e1metros descritos en el fichero fstab son los siguientes: Defaults : asigna las opciones de montaje predeterminadas. Estas opciones son: rw , suid , dev , exec , auto , nouser y async . Dump : indica si es necesario realizar una copia de seguirdad del sistema de ficheros. Puesto que no tenemos dump instalado en nuestro sistema debemos establecer 0. Pass : utilizado por fsck para decidir el orden de comprobaci\u00f3n de los sistemas de ficheros. No queremos que realice ninguna comprobaci\u00f3n por lo que le indicamos 0. Fuente: Wiki Archlinux","title":"NFS Service"},{"location":"Hardware/Proyecto-Celulosa/#scripts","text":"En este apartado explicaremos los scripts que se han realizado para diferentes trabajos que queremos que realice la Raspberry. Este primer script tomar\u00e1 una fotograf\u00eda cada 30 segundos . Utilizaremos cron para que ejecute dicho script cada minuto, por lo tanto obtendremos fotograf\u00edas cada 30 segundos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash #Establecemos el nombre que daremos al documento. FECHA = $( date | tr -s ' ' '-' | cut -d '-' -f 1 -4 ) #Ejecutamos el comando para tomar la fotograf\u00eda. raspistill -o /usr/share/nginx/html/Fotos/ $FECHA .jpg #Pausamos el script durante 30 segundos. sleep 30s #Volvemos a generar la variable, si no tomar\u00eda el mismo nombre que el fichero anterior. FECHA = $( date | tr -s ' ' '-' | cut -d '-' -f 1 -4 ) #Ejecutamos de nuevo el comando para tomar la fotograf\u00eda. raspistill -o /usr/share/nginx/html/Fotos/ $FECHA .jpg En este segundo script lo que pretendemos es almacenar las fotograf\u00edas que se realizan durante una hora en un directorio. Este directorio tomar\u00e1 como nombre la fecha y hora de las fotograf\u00edas que se realicen durante una hora completa. Es decir las fotograf\u00edas que se realicen entre las 17:00 y las 18:00 se almacenar\u00e1n en un directorio con el nombre Wed-May-8-17:00/. 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash for i in /usr/share/nginx/html/Fotos/*.jpg do DIRECTORY = $( basename $i | tr -s ':' '-' | cut -d '-' -f 1 -4 ) \\: 00 if [ ! -d /usr/share/nginx/html/Fotos/ $DIRECTORY ] ; then mkdir /usr/share/nginx/html/Fotos/ $DIRECTORY mv $i /usr/share/nginx/html/Fotos/ $DIRECTORY / else mv $i /usr/share/nginx/html/Fotos/ $DIRECTORY / fi done Por \u00faltimo, este script tiene una funci\u00f3n similar al anterior. Lo que pretendemos es que todos los directorios que se hayan creado durante un d\u00eda se almacenen en otro que llevar\u00e1 como nombre la fecha (sin hora). Siguiendo con el ejemplo del script anterior, todos los directorios que se hubiesen creado durante ese d\u00eda se almacenar\u00eda en otro con el nombre Wed-May-8. 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash for i in /usr/share/nginx/html/Fotos/*00 do DIRECTORY = $( basename $i | tr -s ':' '-' | cut -d '-' -f 1 -3 ) if [ ! -d /usr/share/nginx/html/Fotos/ $DIRECTORY ] ; then mkdir /usr/share/nginx/html/Fotos/ $DIRECTORY mv $i /usr/share/nginx/html/Fotos/ $DIRECTORY / else mv $i /usr/share/nginx/html/Fotos/ $DIRECTORY fi done","title":"Scripts"},{"location":"Hardware/Proyecto-Celulosa/#cron","text":"Para que los scripts que hemos creado en el apartado anterior se ejecuten autom\u00e1ticamente en el horario que nosotros decidamos es necesario hacer uso de el servicio cron . Su uso es muy sencillo, \u00fanicamente es necesario conocer la sintaxis, que podemos consultarla en el fichero /etc/crontab . Para modificar el fichero que lee el servicio cron debemos ejecutar crontab -e , el cual abrir\u00e1 el editor de texto vi para insertar las l\u00edneas que deseemos. En nuestro caso insertaremos tres l\u00edneas, una por cada script que deseamos ejecutar. 1 2 3 4 5 6 #Ejecuci\u00f3n cada minuto */1 * * * * /root/fotos.sh #Ejecuci\u00f3n una vez cada hora @hourly /root/mover.sh #Ejecuci\u00f3n una vez al d\u00eda @daily /root/moverdirectorios.sh En la siguiente tabla extra\u00edda de la wiki de Ubuntu podemos ver otra forma de sintaxis m\u00e1s reducida. Cadena Significado @reboot Se ejecuta una vez, al inicio del sistema. @yearly Se ejecuta una vez al a\u00f1o \"0 0 1 1 *\" @annually Igual que @yearly. @monthly Se ejecuta una vez al mes \"0 0 1 * *\". @weekly Se ejecuta una vez por semana \"0 0 * * 0\". @daily Se ejecuta una vez al d\u00eda \"0 0 * \". @midnight Igual que @daily. @hourly Se ejecuta una vez por hora \"0 * * \".","title":"Cron"},{"location":"Hardware/Proyecto-Celulosa/#resultado-final","text":"El resultado final es el siguiente:","title":"Resultado final"},{"location":"Hardware/Proyecto-Celulosa/#enlaces-de-interes","text":"How to Setup NFS Raspistill","title":"Enlaces de inter\u00e9s"},{"location":"Hardware/Raspberry-Pi/","text":"Raspberry Pi # Preparaci\u00f3n # Para poder hacer uso de una Raspberry Pi como si de un ordenador se tratase, necesitamos instalar un Sistema Operativo en una tarjeta MicroSD. \u00bfC\u00f3mo ser realiza esto? Necesitamos conectar una tarjeta MicroSD a un ordenador, para ello probablemente ser\u00e1 necesario un lector de tarjetas con conexi\u00f3n USB (en caso de que tu equipo tenga lector de tarjetas no lo necesitar\u00e1s), un dispositivo como este . Una vez que tenemos la tarjeta MicroSD y el lector de tarjetas, procedemos a realizar la instalaci\u00f3n del Sistema Operativo que deseemos. En nuestro caso hemos seleccionado CentOS , de la familia Red Hat , puesto que es el que hemos estudiado durante el curso. El microprocesador con el que cuenta la Raspberry Pi 3b es de la familia ARM con arquitectura de 64 bits . Esto es necesario tenerlo en cuenta a la hora de seleccionar la imagen correcta. Teniendo en cuenta esto, acudiremos a la web oficial del Sistema Operativo que vayamos a instalar, y buscaremos la imagen compatible, que habitualmente est\u00e1 renombrada con el nombre del dispositivo, es decir, imagen para Raspberry pi 3 . Despu\u00e9s de navegar por la web de CentOS hemos encontrado el repositorio donde se encuentran las im\u00e1genes compatibles. A pesar de que la Raspberry Pi 3 cuenta con la arquitectura de 64 bits, por el momento CentOS cuenta \u00fanicamente con una versi\u00f3n de 32 bits que es compatible con la Raspberry Pi 3. Una vez que tenemos la imagen descargada en nuestro equipo, procedemos a instalarla en la tarjeta MicroSD, para ello utilizaremos un programa muy sencillo y que funciona muy bien, balenaEtcher . El proceso durar\u00e1 aproximadamente 5 minutos, una vez que haya terminado ya tendremos preparada la tarjeta MicroSD para introducirla en la Raspberry y empezar a trabajar sobre ella. Configuraci\u00f3n de CentOS # Expandir partici\u00f3n root # Vamos a comprobar las particiones que nos crea el Sistema Operativo una vez instalado con el comando lsblk , y como podremos comprobar en la siguiente imagen, la mayor parte del espacio de la tarjeta MicroSD no se est\u00e1 aprovechando. Debemos expandir la partici\u00f3n correspondiente a root ( / ), la que aparece marcada en la imagen anterior. Siguiendo las instrucciones que aparecen en la wiki de CentOS , debemos ejecutar el siguiente comando: 1 /usr/bin/rootfs-expand Deshabilitar selinux: # Es un m\u00f3dulo de seguridad que viene incluido en el Kernel de Linux. Durante el tiempo que hemos estado realizando pruebas nos ha dado bastantes problemas con el servidor web, con lo que hemos decidido deshabilitarlo. Para el control de seguridad haremos uso de la herramienta Firewalld . Para deshabilitarlos debemos abrir el fichero /etc/sysconfig/selinux con cualquier editor de texto que tengamos instalado (por defecto viene instalado el editor vi ). Se ha modificado la l\u00ednea que est\u00e1 marcada en rojo en la captura superior, ha pasado de enforcing a disabled . Para que los cambios resulten efectivos es necesario el reinicio completo de la Raspberry ejecutando el comando reboot . Esto es debido a que este modulo como hemos comentado es parte del kernel del sistema. Warning No se recomiendo deshabilitar el m\u00f3dulo Selinux. En este caso se trata de un entorno de pruebas, por lo que para que resulte m\u00e1s sencillo la puesta en marcha de varios servicios se ha procedido a deshabilitarlo. Configuraci\u00f3n de red # Si tenemos un servidor DHCP en nuestra red local, este le asignar\u00e1 una direcci\u00f3n ip disponible a la Raspberry Pi. Para consultar la direcci\u00f3n ip que tiene nuestra Raspberry Pi debemos ejecutar ip addr . Adem\u00e1s con este comando podemos identificar el nombre que asigna el sistema a nuestra interfaz f\u00edsica. Las tareas que realizaremos durante el curso con la Raspberry Pi nos obligar\u00e1n a conectarnos constantemente a ella, por lo tanto ser\u00eda recomendable disponer de una direcci\u00f3n ip que no cambie continuamente. Para ello vamos a asignarle una direcci\u00f3n ip disponible de forma manual para que sea est\u00e1tica. Modificaremos el fichero /etc/sysconfig/network-scripts/ifcfg-eth0 , donde la \u00faltima parte del nombre del fichero debe corresponder al nombre de la interfaz f\u00edsica. 1 2 3 4 5 6 7 8 DEVICE = eht0 BOOTPROTO = static ONBOOT = yes IPADDR = 192 .168.1.199 NETMASK = 255 .255.255.0 GATEWAY = 192 .168.1.254 DNS1 = 192 .168.1.254 DNS2 = 1 .1.1.1 Actualizar Rasbperry Pi # Actualizaremos todos los paquetes disponibles, para ello ejecutaremos el siguiente comando: 1 yum update Conexi\u00f3n con la Raspberry Pi # Para trabajar de una forma m\u00e1s c\u00f3moda con la Rasperry Pi nos conectaremos remotamente, para ello utilizaremos el servidor OpenSSH. En la imagen de CentOS viene por defecto activado, pero lo comprobaremos ejecutando systemctl status sshd . Como vemos, el servidor est\u00e1 activo con lo que para conectarnos remotamente podremos utilizar cualquier cliente ssh. Para Windows disponemos de varias herramientas como MobaXterm y Putty entre otras, y para sistemas como Linux o MacOS podremos utilizar la propia terminal. 1 2 #usuario@direcci\u00f3n_ip_m\u00e1quina_remota ssh root@192.168.1.199 No hemos realizado ninguna modificaci\u00f3n en el fichero de configuraci\u00f3n sshd_config del servidor ssh. Para ampliar m\u00e1s informaci\u00f3n sobre la securizaci\u00f3n del servidor acudir a este enlace . Firewall # FirewallD es un frontend de iptables, en las \u00faltimas versiones de CentOS reemplaza a iptables como herramienta de control de firewall por defecto. El funcionamiento es diferente puesto que FirewallD se basa en el concepto de zonas y servicios en lugar de cadenas y reglas. Las zonas hacen referencia a un conjunto de reglas predeterminadas que en funci\u00f3n de la zona seleccionada se aplican diferentes niveles de seguridad, se permite o bloquea diferente tipo de tr\u00e1fico. Cuando activamos FirewallD se establece la zona p\u00fablica como zona predeterminada. El comando utilizado para la administraci\u00f3n es firewall-cmd . Comandos que nos resultar\u00e1n interesantes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #Verificar el estado del firewall sudo firewall-cmd --state #Verificar la zona por defecto del firewall sudo firewall-cmd --get-default-zone #Listar todas las zonas disponibles sudo firewall-cmd --get-zones #Comprobar que zonas est\u00e1 utilizando nuestra interfaz sudo firewall-cmd --get-active-zones #Mostrar la configuraci\u00f3n de una zona sudo firewall-cmd --zone = public --list-all #Cambiar la zona a una interfaz, con el siguiente comando asignamos la interfaz \"eth0\" a la zona \"work\" sudo firewall-cmd --zone = work --change-interface = eht0 Cuando realizamos cambios en firewalld, si queremos que estos cambios sean persistentes es necesario hacer uso del flag --permanent , si no \u00fanicamente se mantendr\u00e1n durante la sesi\u00f3n actual. Estos cambios no afectan al sistema en ejecuci\u00f3n por lo que ser\u00e1 necesario recargar el servicio con un comando espec\u00edfico. Sabemos que en posteriores sesiones montaremos varios servidores web, por lo tanto configuraremos el firewall para que acepte peticiones http y https . 1 2 3 4 5 6 7 8 #Habilitamos el servicio \"http\" en la zona \"p\u00fablica\", y adem\u00e1s lo hacemos persistente. firewall-cmd --zone = public --permanent --add-service = http #Igual que el comando anterior pero para el servicio \"https\". firewall-cmd --zone = public --permanent --add-service = https #Reiniciamos el servicio. firewall-cmd --reload Copia de seguridad # Una vez que tenemos configurada la Rasperry Pi es importante realizar un bakcup, ya que es muy habitual que la tarjetas MicroSD utilizadas en estos dispositivos dejen de funcionar. Puesto que estamos trabajando con un equipo Windows, vamos utilizar la herramienta Win32DiskImager para crear una imagen de la tarjeta MicroSD de nuestra Raspberry Pi. El funcionamiento de esta aplicaci\u00f3n es muy sencillo, una vez abierto el programa debemos seleccionar el directorio donde queremos guardar la imagen y el dispositivo origen de la misma (en este caso ser\u00e1 la Raspberry Pi que Windows la ha montado en la unidad F:\\). Seleccionaremos la opci\u00f3n Read Only Allocated Partitions en caso de que no se haya seleccionado autom\u00e1ticamente, y pulsaremos Read . Fuentes # CentOS Linux on the Raspberry Pi 3 Special Interest Group - Armhfp Man page for firewall-cmd Introducci\u00f3n a FirewallD en CentOS How to set up a Firewall with FirewallD on CentOS 7 Firewalld.org Using CentOS 7 Minimal","title":"Raspberry Pi"},{"location":"Hardware/Raspberry-Pi/#raspberry-pi","text":"","title":"Raspberry Pi"},{"location":"Hardware/Raspberry-Pi/#preparacion","text":"Para poder hacer uso de una Raspberry Pi como si de un ordenador se tratase, necesitamos instalar un Sistema Operativo en una tarjeta MicroSD. \u00bfC\u00f3mo ser realiza esto? Necesitamos conectar una tarjeta MicroSD a un ordenador, para ello probablemente ser\u00e1 necesario un lector de tarjetas con conexi\u00f3n USB (en caso de que tu equipo tenga lector de tarjetas no lo necesitar\u00e1s), un dispositivo como este . Una vez que tenemos la tarjeta MicroSD y el lector de tarjetas, procedemos a realizar la instalaci\u00f3n del Sistema Operativo que deseemos. En nuestro caso hemos seleccionado CentOS , de la familia Red Hat , puesto que es el que hemos estudiado durante el curso. El microprocesador con el que cuenta la Raspberry Pi 3b es de la familia ARM con arquitectura de 64 bits . Esto es necesario tenerlo en cuenta a la hora de seleccionar la imagen correcta. Teniendo en cuenta esto, acudiremos a la web oficial del Sistema Operativo que vayamos a instalar, y buscaremos la imagen compatible, que habitualmente est\u00e1 renombrada con el nombre del dispositivo, es decir, imagen para Raspberry pi 3 . Despu\u00e9s de navegar por la web de CentOS hemos encontrado el repositorio donde se encuentran las im\u00e1genes compatibles. A pesar de que la Raspberry Pi 3 cuenta con la arquitectura de 64 bits, por el momento CentOS cuenta \u00fanicamente con una versi\u00f3n de 32 bits que es compatible con la Raspberry Pi 3. Una vez que tenemos la imagen descargada en nuestro equipo, procedemos a instalarla en la tarjeta MicroSD, para ello utilizaremos un programa muy sencillo y que funciona muy bien, balenaEtcher . El proceso durar\u00e1 aproximadamente 5 minutos, una vez que haya terminado ya tendremos preparada la tarjeta MicroSD para introducirla en la Raspberry y empezar a trabajar sobre ella.","title":"Preparaci\u00f3n"},{"location":"Hardware/Raspberry-Pi/#configuracion-de-centos","text":"","title":"Configuraci\u00f3n de CentOS"},{"location":"Hardware/Raspberry-Pi/#expandir-particion-root","text":"Vamos a comprobar las particiones que nos crea el Sistema Operativo una vez instalado con el comando lsblk , y como podremos comprobar en la siguiente imagen, la mayor parte del espacio de la tarjeta MicroSD no se est\u00e1 aprovechando. Debemos expandir la partici\u00f3n correspondiente a root ( / ), la que aparece marcada en la imagen anterior. Siguiendo las instrucciones que aparecen en la wiki de CentOS , debemos ejecutar el siguiente comando: 1 /usr/bin/rootfs-expand","title":"Expandir partici\u00f3n root"},{"location":"Hardware/Raspberry-Pi/#deshabilitar-selinux","text":"Es un m\u00f3dulo de seguridad que viene incluido en el Kernel de Linux. Durante el tiempo que hemos estado realizando pruebas nos ha dado bastantes problemas con el servidor web, con lo que hemos decidido deshabilitarlo. Para el control de seguridad haremos uso de la herramienta Firewalld . Para deshabilitarlos debemos abrir el fichero /etc/sysconfig/selinux con cualquier editor de texto que tengamos instalado (por defecto viene instalado el editor vi ). Se ha modificado la l\u00ednea que est\u00e1 marcada en rojo en la captura superior, ha pasado de enforcing a disabled . Para que los cambios resulten efectivos es necesario el reinicio completo de la Raspberry ejecutando el comando reboot . Esto es debido a que este modulo como hemos comentado es parte del kernel del sistema. Warning No se recomiendo deshabilitar el m\u00f3dulo Selinux. En este caso se trata de un entorno de pruebas, por lo que para que resulte m\u00e1s sencillo la puesta en marcha de varios servicios se ha procedido a deshabilitarlo.","title":"Deshabilitar selinux:"},{"location":"Hardware/Raspberry-Pi/#configuracion-de-red","text":"Si tenemos un servidor DHCP en nuestra red local, este le asignar\u00e1 una direcci\u00f3n ip disponible a la Raspberry Pi. Para consultar la direcci\u00f3n ip que tiene nuestra Raspberry Pi debemos ejecutar ip addr . Adem\u00e1s con este comando podemos identificar el nombre que asigna el sistema a nuestra interfaz f\u00edsica. Las tareas que realizaremos durante el curso con la Raspberry Pi nos obligar\u00e1n a conectarnos constantemente a ella, por lo tanto ser\u00eda recomendable disponer de una direcci\u00f3n ip que no cambie continuamente. Para ello vamos a asignarle una direcci\u00f3n ip disponible de forma manual para que sea est\u00e1tica. Modificaremos el fichero /etc/sysconfig/network-scripts/ifcfg-eth0 , donde la \u00faltima parte del nombre del fichero debe corresponder al nombre de la interfaz f\u00edsica. 1 2 3 4 5 6 7 8 DEVICE = eht0 BOOTPROTO = static ONBOOT = yes IPADDR = 192 .168.1.199 NETMASK = 255 .255.255.0 GATEWAY = 192 .168.1.254 DNS1 = 192 .168.1.254 DNS2 = 1 .1.1.1","title":"Configuraci\u00f3n de red"},{"location":"Hardware/Raspberry-Pi/#actualizar-rasbperry-pi","text":"Actualizaremos todos los paquetes disponibles, para ello ejecutaremos el siguiente comando: 1 yum update","title":"Actualizar Rasbperry Pi"},{"location":"Hardware/Raspberry-Pi/#conexion-con-la-raspberry-pi","text":"Para trabajar de una forma m\u00e1s c\u00f3moda con la Rasperry Pi nos conectaremos remotamente, para ello utilizaremos el servidor OpenSSH. En la imagen de CentOS viene por defecto activado, pero lo comprobaremos ejecutando systemctl status sshd . Como vemos, el servidor est\u00e1 activo con lo que para conectarnos remotamente podremos utilizar cualquier cliente ssh. Para Windows disponemos de varias herramientas como MobaXterm y Putty entre otras, y para sistemas como Linux o MacOS podremos utilizar la propia terminal. 1 2 #usuario@direcci\u00f3n_ip_m\u00e1quina_remota ssh root@192.168.1.199 No hemos realizado ninguna modificaci\u00f3n en el fichero de configuraci\u00f3n sshd_config del servidor ssh. Para ampliar m\u00e1s informaci\u00f3n sobre la securizaci\u00f3n del servidor acudir a este enlace .","title":"Conexi\u00f3n con la Raspberry Pi"},{"location":"Hardware/Raspberry-Pi/#firewall","text":"FirewallD es un frontend de iptables, en las \u00faltimas versiones de CentOS reemplaza a iptables como herramienta de control de firewall por defecto. El funcionamiento es diferente puesto que FirewallD se basa en el concepto de zonas y servicios en lugar de cadenas y reglas. Las zonas hacen referencia a un conjunto de reglas predeterminadas que en funci\u00f3n de la zona seleccionada se aplican diferentes niveles de seguridad, se permite o bloquea diferente tipo de tr\u00e1fico. Cuando activamos FirewallD se establece la zona p\u00fablica como zona predeterminada. El comando utilizado para la administraci\u00f3n es firewall-cmd . Comandos que nos resultar\u00e1n interesantes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #Verificar el estado del firewall sudo firewall-cmd --state #Verificar la zona por defecto del firewall sudo firewall-cmd --get-default-zone #Listar todas las zonas disponibles sudo firewall-cmd --get-zones #Comprobar que zonas est\u00e1 utilizando nuestra interfaz sudo firewall-cmd --get-active-zones #Mostrar la configuraci\u00f3n de una zona sudo firewall-cmd --zone = public --list-all #Cambiar la zona a una interfaz, con el siguiente comando asignamos la interfaz \"eth0\" a la zona \"work\" sudo firewall-cmd --zone = work --change-interface = eht0 Cuando realizamos cambios en firewalld, si queremos que estos cambios sean persistentes es necesario hacer uso del flag --permanent , si no \u00fanicamente se mantendr\u00e1n durante la sesi\u00f3n actual. Estos cambios no afectan al sistema en ejecuci\u00f3n por lo que ser\u00e1 necesario recargar el servicio con un comando espec\u00edfico. Sabemos que en posteriores sesiones montaremos varios servidores web, por lo tanto configuraremos el firewall para que acepte peticiones http y https . 1 2 3 4 5 6 7 8 #Habilitamos el servicio \"http\" en la zona \"p\u00fablica\", y adem\u00e1s lo hacemos persistente. firewall-cmd --zone = public --permanent --add-service = http #Igual que el comando anterior pero para el servicio \"https\". firewall-cmd --zone = public --permanent --add-service = https #Reiniciamos el servicio. firewall-cmd --reload","title":"Firewall"},{"location":"Hardware/Raspberry-Pi/#copia-de-seguridad","text":"Una vez que tenemos configurada la Rasperry Pi es importante realizar un bakcup, ya que es muy habitual que la tarjetas MicroSD utilizadas en estos dispositivos dejen de funcionar. Puesto que estamos trabajando con un equipo Windows, vamos utilizar la herramienta Win32DiskImager para crear una imagen de la tarjeta MicroSD de nuestra Raspberry Pi. El funcionamiento de esta aplicaci\u00f3n es muy sencillo, una vez abierto el programa debemos seleccionar el directorio donde queremos guardar la imagen y el dispositivo origen de la misma (en este caso ser\u00e1 la Raspberry Pi que Windows la ha montado en la unidad F:\\). Seleccionaremos la opci\u00f3n Read Only Allocated Partitions en caso de que no se haya seleccionado autom\u00e1ticamente, y pulsaremos Read .","title":"Copia de seguridad"},{"location":"Hardware/Raspberry-Pi/#fuentes","text":"CentOS Linux on the Raspberry Pi 3 Special Interest Group - Armhfp Man page for firewall-cmd Introducci\u00f3n a FirewallD en CentOS How to set up a Firewall with FirewallD on CentOS 7 Firewalld.org Using CentOS 7 Minimal","title":"Fuentes"},{"location":"Hardware/Rockstor/","text":"Rockstor # Introducci\u00f3n # Rocsktor es el sistema operativo que utilizaremos en nuestro NAS. Est\u00e1 basado en la distribuci\u00f3n de Linux CentOS, adaptada para una configuraci\u00f3n sencilla desde un navegador web. Entre una de sus principales caracter\u00edsticas, utiliza como sistema de ficheros BTRFS (integrado en el Kernel de Linux), lo que permite tener una serie de beneficios, tales como copy-on-write , respecto a otro tipo de sistema de ficheros como ext4. En el siguiente enlace podemos encontrar un resumen de las principales caracter\u00edsticas de este sistema operativo. Instalaci\u00f3n # Para proceder a la instalaci\u00f3n es necesario consultar los requisitos m\u00ednimos de hardware que necesitaremos. En la propia web de Rockstor podemos consultar estos datos . En la siguiente tabla exponemos una comparativa de los requisitos m\u00ednimos y el equipamiento introducido. Requisitos m\u00ednimos NAS Rockstar 64-bit Intel o AMD 64-bit AMD 2GB RAM 4GB RAM 8GB espacio para el SO 80GB espacio para el SO 1 disco extra para almacenamiento 1 disco de 250GB para almacenamiento Los pasos para la instalaci\u00f3n del mismo son realmente sencillos. Al igual que sucede con cualquier sistema operativo, necesitamos crear una unidad booteable (DVD, USB, etc.), utilizando las herramientas disponibles en Windows, Linux o MacOS. Una vez que tenemos preparada la unidad booteable , pincharemos dicha unidad a nuestro NAS y en la BIOS seleccionaremos como unidad de arranque principal el dispositivo que hayamos preparado como unidad de arranque. Almacenamiento # En nuestra instalaci\u00f3n contamos con dos discos: Un disco para el SO de 80GB Un disco de 250GB para datos (todos los datos ) Rockstor trabaja con el disco en crudo, es decir debemos entregarle el disco sin particiones. En caso de que tengamos alguna partici\u00f3n en alguno de los discos que hemos a\u00f1adido al NAS tendremos posibilidad de eliminar dichas particiones a trav\u00e9s de la interfaz web. En este sistema, lo que entendemos habitualmente como particiones en este caso ser\u00e1n pools , que nos permite combinar diferentes discos (RAIDs) como si fuese un \u00fanico volumen. Nuestra elecci\u00f3n al contar \u00fanicamente con una unidad para almacenamiento de datos, ha sido la creaci\u00f3n de un pool \"simple\" con toda la capacidad del disco. La interfaz nos permite aplicar diferentes configuraciones, como la compresi\u00f3n u opciones de \"montado\" de la unidad, aunque nosotros hemos mantenido las opciones por defecto. Shares # Una vez que tenemos el pool creado, pasamos a crear shares (podemos entenderlos como directorios). La creaci\u00f3n de estos directorios es muy sencilla, en el momento que nos encontramos del proyecto contamos con dos directorios, que son los siguientes: Datos: directorio que utilizaremos para dejar capturas y toda la informaci\u00f3n referente al proyecto. Im\u00e1genes: directorio donde almacenaremos la im\u00e1genes (backups) de los equipos. Samba # La principal funci\u00f3n de un NAS es tener datos de una forma centralizada y poder acceder a ellos a trav\u00e9s de la red. Para ello es necesario tener alg\u00fan servicio orientado a la transferencia de archivos como puede ser FTP, SMB o NFS (Rockstor dispone de estos tres servicios preinstalados). Hemos seleccionado SMB por ser un protocolo extendido y por su compatibilidad con los diferentes Sistemas Operativos. Tal y como hemos comentado este servicio viene preinstalado, pero no activado, por lo tanto es necesario acudir al men\u00fa servicies para habilitarlo. Una vez que tenemos el servicio activado, necesitamos crear un samba export , as\u00ed lo denomina Rockstor, pero es simplemente una unidad compartida a trav\u00e9s de SMB. Para continuar con el apartado anterior, crearemos las unidades en base a los directorios datos e imagenes . La creaci\u00f3n es muy sencilla, una vez que estamos en la pesta\u00f1a de \"Samba\", tenemos que pulsar el siguiente bot\u00f3n, , el cual nos llevar\u00e1 a la siguiente ventana: Los par\u00e1metros que debemos considerar son los siguientes: Shares to export : aqu\u00ed seleccionamos el directorio que queremos compartir. Admin users : elecci\u00f3n de los usuarios con permisos de acceso. Browseable : permitir que el recurso compartido se muestre visible. Guest ok : permisos para invitados. Read only : recurso de s\u00f3lo lectura. Tal y como vemos, podemos personalizar la configuraci\u00f3n a\u00f1adiendo m\u00e1s directivas en custom configuration . En este enlace podemos obtener m\u00e1s informaci\u00f3n sobre los par\u00e1metros de configuraci\u00f3n de samba. Los directorios compartidos con los que nos encontramos son los siguientes:","title":"Rockstor"},{"location":"Hardware/Rockstor/#rockstor","text":"","title":"Rockstor"},{"location":"Hardware/Rockstor/#introduccion","text":"Rocsktor es el sistema operativo que utilizaremos en nuestro NAS. Est\u00e1 basado en la distribuci\u00f3n de Linux CentOS, adaptada para una configuraci\u00f3n sencilla desde un navegador web. Entre una de sus principales caracter\u00edsticas, utiliza como sistema de ficheros BTRFS (integrado en el Kernel de Linux), lo que permite tener una serie de beneficios, tales como copy-on-write , respecto a otro tipo de sistema de ficheros como ext4. En el siguiente enlace podemos encontrar un resumen de las principales caracter\u00edsticas de este sistema operativo.","title":"Introducci\u00f3n"},{"location":"Hardware/Rockstor/#instalacion","text":"Para proceder a la instalaci\u00f3n es necesario consultar los requisitos m\u00ednimos de hardware que necesitaremos. En la propia web de Rockstor podemos consultar estos datos . En la siguiente tabla exponemos una comparativa de los requisitos m\u00ednimos y el equipamiento introducido. Requisitos m\u00ednimos NAS Rockstar 64-bit Intel o AMD 64-bit AMD 2GB RAM 4GB RAM 8GB espacio para el SO 80GB espacio para el SO 1 disco extra para almacenamiento 1 disco de 250GB para almacenamiento Los pasos para la instalaci\u00f3n del mismo son realmente sencillos. Al igual que sucede con cualquier sistema operativo, necesitamos crear una unidad booteable (DVD, USB, etc.), utilizando las herramientas disponibles en Windows, Linux o MacOS. Una vez que tenemos preparada la unidad booteable , pincharemos dicha unidad a nuestro NAS y en la BIOS seleccionaremos como unidad de arranque principal el dispositivo que hayamos preparado como unidad de arranque.","title":"Instalaci\u00f3n"},{"location":"Hardware/Rockstor/#almacenamiento","text":"En nuestra instalaci\u00f3n contamos con dos discos: Un disco para el SO de 80GB Un disco de 250GB para datos (todos los datos ) Rockstor trabaja con el disco en crudo, es decir debemos entregarle el disco sin particiones. En caso de que tengamos alguna partici\u00f3n en alguno de los discos que hemos a\u00f1adido al NAS tendremos posibilidad de eliminar dichas particiones a trav\u00e9s de la interfaz web. En este sistema, lo que entendemos habitualmente como particiones en este caso ser\u00e1n pools , que nos permite combinar diferentes discos (RAIDs) como si fuese un \u00fanico volumen. Nuestra elecci\u00f3n al contar \u00fanicamente con una unidad para almacenamiento de datos, ha sido la creaci\u00f3n de un pool \"simple\" con toda la capacidad del disco. La interfaz nos permite aplicar diferentes configuraciones, como la compresi\u00f3n u opciones de \"montado\" de la unidad, aunque nosotros hemos mantenido las opciones por defecto.","title":"Almacenamiento"},{"location":"Hardware/Rockstor/#shares","text":"Una vez que tenemos el pool creado, pasamos a crear shares (podemos entenderlos como directorios). La creaci\u00f3n de estos directorios es muy sencilla, en el momento que nos encontramos del proyecto contamos con dos directorios, que son los siguientes: Datos: directorio que utilizaremos para dejar capturas y toda la informaci\u00f3n referente al proyecto. Im\u00e1genes: directorio donde almacenaremos la im\u00e1genes (backups) de los equipos.","title":"Shares"},{"location":"Hardware/Rockstor/#samba","text":"La principal funci\u00f3n de un NAS es tener datos de una forma centralizada y poder acceder a ellos a trav\u00e9s de la red. Para ello es necesario tener alg\u00fan servicio orientado a la transferencia de archivos como puede ser FTP, SMB o NFS (Rockstor dispone de estos tres servicios preinstalados). Hemos seleccionado SMB por ser un protocolo extendido y por su compatibilidad con los diferentes Sistemas Operativos. Tal y como hemos comentado este servicio viene preinstalado, pero no activado, por lo tanto es necesario acudir al men\u00fa servicies para habilitarlo. Una vez que tenemos el servicio activado, necesitamos crear un samba export , as\u00ed lo denomina Rockstor, pero es simplemente una unidad compartida a trav\u00e9s de SMB. Para continuar con el apartado anterior, crearemos las unidades en base a los directorios datos e imagenes . La creaci\u00f3n es muy sencilla, una vez que estamos en la pesta\u00f1a de \"Samba\", tenemos que pulsar el siguiente bot\u00f3n, , el cual nos llevar\u00e1 a la siguiente ventana: Los par\u00e1metros que debemos considerar son los siguientes: Shares to export : aqu\u00ed seleccionamos el directorio que queremos compartir. Admin users : elecci\u00f3n de los usuarios con permisos de acceso. Browseable : permitir que el recurso compartido se muestre visible. Guest ok : permisos para invitados. Read only : recurso de s\u00f3lo lectura. Tal y como vemos, podemos personalizar la configuraci\u00f3n a\u00f1adiendo m\u00e1s directivas en custom configuration . En este enlace podemos obtener m\u00e1s informaci\u00f3n sobre los par\u00e1metros de configuraci\u00f3n de samba. Los directorios compartidos con los que nos encontramos son los siguientes:","title":"Samba"},{"location":"Hardware/Servidor/","text":"Construyendo un servidor # Placa Base # La placa base es una de las partes fundamentales entre otras cosas porque es lo que interconectar\u00e1 todo y adem\u00e1s nos dimensionar\u00e1 el tama\u00f1o del servidor o pc que vayamos a montar. y a partir de esta podremos elegir el resto de componentes. Buscamos una placa con factor de forma Mini ITX para disponer de un servidor de un tama\u00f1o ajustado, y adem\u00e1s que cuente con CPU integrada de bajo consumo preferiblemente con refrigeraci\u00f3n pasiva, de ese modo evitaremos tener que poner ventilaci\u00f3n extra y disminuiremos el ruido. Teniendo en cuenta esto, hemos optado por una placa base de la marca Supermicro , ya que es una empresa orientada a la fabricaci\u00f3n de componentes para servidores con muchos a\u00f1os de experiencia. El modelo de placa base escogida es la Supermicro X11SDV-8C.TLN2F-O , en la siguiente tabla se recogen las caracter\u00edsticas m\u00e1s destacadas: CARACTER\u00cdSTICAS Factor de forma Mini-ITX Procesador Intel Xeon D-2141I (8 nucleos, 16 hilos) RAM DDR4 hasta 256GB (compatible con memoria ECC Y RDIMM) SATA SATA III 4 RAIDs compatibles 0,1,5 y 10 LAN 2 puerto 10Gb + 1 puerto IPMI Ranuras de expansi\u00f3n 1 PCI-E 3.0 x 8 + 1PCI-E x 4 via OCuLink Procesador # El coraz\u00f3n de todo equipo lo encontramos en el procesador. Como hemos visto en la secci\u00f3n anterior, la placa base escogida viene con un procesador incorporado, en este caso es el Intel Xeon D-2141I perteneciente a la familia D , orientados al bajo consumo. Es un procesador reciente, su fecha de lanzamiento fue el primer trimestre del 2018. Las caracter\u00edsticas m\u00e1s destacadas que podemos obtener de la web oficial de Intel son las siguientes: CARACTER\u00cdSTICAS N\u00facleos 8 Hilos 16 Frecuencia base 2,20 GHz Frecuencia turbo 3,00 GHz Cach\u00e9 11 MB TDP 65W Memoria RAM # La placa base elegida dispone de 4 ranuras para la memoria RAM, por lo tanto aprovecharemos todas las ranuras, insertando 4 m\u00f3dulos de 8GB cada uno, quedando un total de 32GB de memoria RAM. La memoria elegida son unos m\u00f3dulos de Dell DDR4 a una frecuencia de 2133 MHz, que es la velocidad soportada por la placa base. Adem\u00e1s estos m\u00f3dulos son ECC 1 , que son m\u00f3dulos orientados a sistemas profesionales como servidores. Almacenamiento # La placa base nos marca el n\u00famero de unidades de almacenamiento m\u00e1ximo del que podremos disponer. En este caso para el almacenamiento dispondremos de lo siguiente: NVMe: para el Sistema Operativo v\u00eda OCuLink. HDD 2,5\": para el almacenamiento masivo de datos. DISCO N\u00ba Unidades RAID NVMe 1 - 250 GB - HDD 4 - 4 TB RAID 1+0 Para el almacenamiento de datos hemos elegido RAID 10 que como hemos podido ver en las especificaciones de la placa base es totalmente compatible. Esto nos proporciona mayor velocidad de lectura y escritura, y adem\u00e1s contamos con la tolerancia a fallos. En la siguiente captura se puede observar de manera l\u00f3gica como se comporta un RAID 10. Fuente de alimentaci\u00f3n # Estamos montando un servidor de tama\u00f1o reducido, por lo que debemos escoger una fuente de alimentaci\u00f3n acorde, para ello existen las fuentes SFX 2 . El consumo de nuestro equipo no ser\u00e1 muy elevado teniendo en cuenta que el procesador ser\u00e1 el componente de mayor consumo, y este cuenta con un TDP de 65W, y tal y como hemos mencionado, pertenece a la gama D de Intel Xeon, que son los procesadores de bajo consumo. La fuente escogida es la Corsair SF450 de 450W de potencia. Es una fuente modular con lo cual nos facilitar\u00e1 la gesti\u00f3n del cableado, importante a tener en cuenta en la elecci\u00f3n del siguiente componente, la caja. Caja # Llegamos al \u00faltimo componente que necesitamos para terminar con el montaje de nuestro servidor, la caja. Acorde al tama\u00f1o del resto de componentes, la caja ha escoger ser\u00e1 compacta, que no ocupe demasiado pero que tenga espacio suficiente para albergar todos los discos y para una posible ampliaci\u00f3n. La caja elegida es la SilverStone SST-CS280B ya que cumple con todos nuestro requisitos. Las caracter\u00edsticas m\u00e1s destacables son las siguientes: CARACTER\u00cdSTICAS Placas base Mini-DTX/Mini-ITX Fuente de alimentaci\u00f3n SFX Capacidad 8 discos duros 2,5\" Funci\u00f3n SATA Hot-Swap SAI/UPS # El servidor es una parte cr\u00edtica del sistema inform\u00e1tico por lo que es importante que ante cualquier problema en la red el\u00e9ctrica, el servidor no se vea afectado y en consecuencia los discos, donde se encuentran almacenados los datos que no queremos perder. Para evitar esto disponemos en el mercado de una soluci\u00f3n, que son los dispositivos de alimentaci\u00f3n ininterrumpida. Existen varias clases de SAI, offline, interactivo y online. Hemos optado por la soluci\u00f3n online , es la alternativa menos econ\u00f3mica pero la m\u00e1s completa de todas. La principal diferencia que encontramos en los SAI de tipo online con respecto a los dem\u00e1s, es que la energ\u00eda el\u00e9ctrica la suministra directamente desde sus bater\u00edas a los dispositivos que est\u00e1n directamente conectados. Por otro lado, a la hora de elegir el SAI es necesario saber que dispositivos electr\u00f3nicos conectaremos, y que consumo en vatios generar\u00e1n. La unidad de medida que utilizan los SAIs es la \"potencia aparente\" que se mide en Va 3 . Para hacer la equivalencia se utiliza el factor de potencia que dependiendo del tipo de SAI ronde entorno al 70-90%. Es una practica habitual por parte de los fabricantes incluir una equivalencia entre los Va y los W del SAI. En el momento de escoger el SAI adecuado, es necesario incrementar un 20% la potencia real de todos los dispositivos conectados (en nuestro caso \u00fanicamente tendremos conectado el servidor), para que las bater\u00edas puedan suministrar energ\u00eda durante un m\u00ednimo de tiempo para que los dispositivos puedan ser apagados correctamente. \u00danicamente conectaremos el servidor al SAI, el consumo aproximado del mismo a plena carga no superar\u00e1 los 300W. Realizando el c\u00e1lculo teniendo en cuenta el factor de potencia, con un SAI de 1000Va ser\u00e1 suficiente para mantenerlo 15 minutos encendido. El modelo elegido es el SLC TWIN PRO2 de la marca Salicru. Entre sus caracter\u00edsticas destaca que cuenta con su propio software de monitorizaci\u00f3n para las diferentes plataformas (Windows, Linux y MacOS). Adem\u00e1s cuenta con una pantalla LCD que permite ver r\u00e1pidamente el estado del SAI. Presupuesto Total # COMPONENTES PRECIO Placa Base + procesador 867,15\u20ac Memoria RAM 597,80\u20ac Almacenamiento 651,60\u20ac + 223,00\u20ac Fuente de alimentaci\u00f3n 88,90\u20ac Caja 177,90\u20ac SAI 359\u20ac TOTAL 2965,35\u20ac Note Los precios de la tabla han sido consultados a fecha 26/05/2019. Fuentes # Tipos de SAIs Selector de SAI APC DIY NAS 2017 FreeNAS Home Server Error Correcting Code \u21a9 Small Factor Form \u21a9 Voltiamperio \u21a9","title":"Presupuesto Servidor"},{"location":"Hardware/Servidor/#construyendo-un-servidor","text":"","title":"Construyendo un servidor"},{"location":"Hardware/Servidor/#placa-base","text":"La placa base es una de las partes fundamentales entre otras cosas porque es lo que interconectar\u00e1 todo y adem\u00e1s nos dimensionar\u00e1 el tama\u00f1o del servidor o pc que vayamos a montar. y a partir de esta podremos elegir el resto de componentes. Buscamos una placa con factor de forma Mini ITX para disponer de un servidor de un tama\u00f1o ajustado, y adem\u00e1s que cuente con CPU integrada de bajo consumo preferiblemente con refrigeraci\u00f3n pasiva, de ese modo evitaremos tener que poner ventilaci\u00f3n extra y disminuiremos el ruido. Teniendo en cuenta esto, hemos optado por una placa base de la marca Supermicro , ya que es una empresa orientada a la fabricaci\u00f3n de componentes para servidores con muchos a\u00f1os de experiencia. El modelo de placa base escogida es la Supermicro X11SDV-8C.TLN2F-O , en la siguiente tabla se recogen las caracter\u00edsticas m\u00e1s destacadas: CARACTER\u00cdSTICAS Factor de forma Mini-ITX Procesador Intel Xeon D-2141I (8 nucleos, 16 hilos) RAM DDR4 hasta 256GB (compatible con memoria ECC Y RDIMM) SATA SATA III 4 RAIDs compatibles 0,1,5 y 10 LAN 2 puerto 10Gb + 1 puerto IPMI Ranuras de expansi\u00f3n 1 PCI-E 3.0 x 8 + 1PCI-E x 4 via OCuLink","title":"Placa Base"},{"location":"Hardware/Servidor/#procesador","text":"El coraz\u00f3n de todo equipo lo encontramos en el procesador. Como hemos visto en la secci\u00f3n anterior, la placa base escogida viene con un procesador incorporado, en este caso es el Intel Xeon D-2141I perteneciente a la familia D , orientados al bajo consumo. Es un procesador reciente, su fecha de lanzamiento fue el primer trimestre del 2018. Las caracter\u00edsticas m\u00e1s destacadas que podemos obtener de la web oficial de Intel son las siguientes: CARACTER\u00cdSTICAS N\u00facleos 8 Hilos 16 Frecuencia base 2,20 GHz Frecuencia turbo 3,00 GHz Cach\u00e9 11 MB TDP 65W","title":"Procesador"},{"location":"Hardware/Servidor/#memoria-ram","text":"La placa base elegida dispone de 4 ranuras para la memoria RAM, por lo tanto aprovecharemos todas las ranuras, insertando 4 m\u00f3dulos de 8GB cada uno, quedando un total de 32GB de memoria RAM. La memoria elegida son unos m\u00f3dulos de Dell DDR4 a una frecuencia de 2133 MHz, que es la velocidad soportada por la placa base. Adem\u00e1s estos m\u00f3dulos son ECC 1 , que son m\u00f3dulos orientados a sistemas profesionales como servidores.","title":"Memoria RAM"},{"location":"Hardware/Servidor/#almacenamiento","text":"La placa base nos marca el n\u00famero de unidades de almacenamiento m\u00e1ximo del que podremos disponer. En este caso para el almacenamiento dispondremos de lo siguiente: NVMe: para el Sistema Operativo v\u00eda OCuLink. HDD 2,5\": para el almacenamiento masivo de datos. DISCO N\u00ba Unidades RAID NVMe 1 - 250 GB - HDD 4 - 4 TB RAID 1+0 Para el almacenamiento de datos hemos elegido RAID 10 que como hemos podido ver en las especificaciones de la placa base es totalmente compatible. Esto nos proporciona mayor velocidad de lectura y escritura, y adem\u00e1s contamos con la tolerancia a fallos. En la siguiente captura se puede observar de manera l\u00f3gica como se comporta un RAID 10.","title":"Almacenamiento"},{"location":"Hardware/Servidor/#fuente-de-alimentacion","text":"Estamos montando un servidor de tama\u00f1o reducido, por lo que debemos escoger una fuente de alimentaci\u00f3n acorde, para ello existen las fuentes SFX 2 . El consumo de nuestro equipo no ser\u00e1 muy elevado teniendo en cuenta que el procesador ser\u00e1 el componente de mayor consumo, y este cuenta con un TDP de 65W, y tal y como hemos mencionado, pertenece a la gama D de Intel Xeon, que son los procesadores de bajo consumo. La fuente escogida es la Corsair SF450 de 450W de potencia. Es una fuente modular con lo cual nos facilitar\u00e1 la gesti\u00f3n del cableado, importante a tener en cuenta en la elecci\u00f3n del siguiente componente, la caja.","title":"Fuente de alimentaci\u00f3n"},{"location":"Hardware/Servidor/#caja","text":"Llegamos al \u00faltimo componente que necesitamos para terminar con el montaje de nuestro servidor, la caja. Acorde al tama\u00f1o del resto de componentes, la caja ha escoger ser\u00e1 compacta, que no ocupe demasiado pero que tenga espacio suficiente para albergar todos los discos y para una posible ampliaci\u00f3n. La caja elegida es la SilverStone SST-CS280B ya que cumple con todos nuestro requisitos. Las caracter\u00edsticas m\u00e1s destacables son las siguientes: CARACTER\u00cdSTICAS Placas base Mini-DTX/Mini-ITX Fuente de alimentaci\u00f3n SFX Capacidad 8 discos duros 2,5\" Funci\u00f3n SATA Hot-Swap","title":"Caja"},{"location":"Hardware/Servidor/#saiups","text":"El servidor es una parte cr\u00edtica del sistema inform\u00e1tico por lo que es importante que ante cualquier problema en la red el\u00e9ctrica, el servidor no se vea afectado y en consecuencia los discos, donde se encuentran almacenados los datos que no queremos perder. Para evitar esto disponemos en el mercado de una soluci\u00f3n, que son los dispositivos de alimentaci\u00f3n ininterrumpida. Existen varias clases de SAI, offline, interactivo y online. Hemos optado por la soluci\u00f3n online , es la alternativa menos econ\u00f3mica pero la m\u00e1s completa de todas. La principal diferencia que encontramos en los SAI de tipo online con respecto a los dem\u00e1s, es que la energ\u00eda el\u00e9ctrica la suministra directamente desde sus bater\u00edas a los dispositivos que est\u00e1n directamente conectados. Por otro lado, a la hora de elegir el SAI es necesario saber que dispositivos electr\u00f3nicos conectaremos, y que consumo en vatios generar\u00e1n. La unidad de medida que utilizan los SAIs es la \"potencia aparente\" que se mide en Va 3 . Para hacer la equivalencia se utiliza el factor de potencia que dependiendo del tipo de SAI ronde entorno al 70-90%. Es una practica habitual por parte de los fabricantes incluir una equivalencia entre los Va y los W del SAI. En el momento de escoger el SAI adecuado, es necesario incrementar un 20% la potencia real de todos los dispositivos conectados (en nuestro caso \u00fanicamente tendremos conectado el servidor), para que las bater\u00edas puedan suministrar energ\u00eda durante un m\u00ednimo de tiempo para que los dispositivos puedan ser apagados correctamente. \u00danicamente conectaremos el servidor al SAI, el consumo aproximado del mismo a plena carga no superar\u00e1 los 300W. Realizando el c\u00e1lculo teniendo en cuenta el factor de potencia, con un SAI de 1000Va ser\u00e1 suficiente para mantenerlo 15 minutos encendido. El modelo elegido es el SLC TWIN PRO2 de la marca Salicru. Entre sus caracter\u00edsticas destaca que cuenta con su propio software de monitorizaci\u00f3n para las diferentes plataformas (Windows, Linux y MacOS). Adem\u00e1s cuenta con una pantalla LCD que permite ver r\u00e1pidamente el estado del SAI.","title":"SAI/UPS"},{"location":"Hardware/Servidor/#presupuesto-total","text":"COMPONENTES PRECIO Placa Base + procesador 867,15\u20ac Memoria RAM 597,80\u20ac Almacenamiento 651,60\u20ac + 223,00\u20ac Fuente de alimentaci\u00f3n 88,90\u20ac Caja 177,90\u20ac SAI 359\u20ac TOTAL 2965,35\u20ac Note Los precios de la tabla han sido consultados a fecha 26/05/2019.","title":"Presupuesto Total"},{"location":"Hardware/Servidor/#fuentes","text":"Tipos de SAIs Selector de SAI APC DIY NAS 2017 FreeNAS Home Server Error Correcting Code \u21a9 Small Factor Form \u21a9 Voltiamperio \u21a9","title":"Fuentes"},{"location":"Herramientas/Easy2boot/","text":"Easy2boot # Introducci\u00f3n # Durante el desarrollo del proyecto hemos necesitado instalar diferentes sistemas operativos y arrancar equipos con herramientas booteables . Para ello hemos utilizado una herramienta muy potente, llamada Easy2boot . Esta magn\u00edfica herramienta nos permite introducir en un \u00fanico USB ISOS de diferentes sistemas operativos y herramientas como Hirens, GParted, etc. El l\u00edmite ser\u00e1 la capacidad de almacenamiento con la que cuenta nuestro USB. En este caso contamos con un USB de 32 GB, suficiente para tener varias ISOS de Windows y Linux, y adem\u00e1s contar con alguna herramienta de las mencionadas anteriormente. La creaci\u00f3n de este USB multiboot es bastante sencilla, hay una gu\u00eda en ingl\u00e9s bastante completa en su p\u00e1gina web . A pesar de ello, vamos a resumir el proceso que hemos seguido para crear este USB. Proceso de instalaci\u00f3n Easy2boot # En primer lugar, necesitamos descargar el fichero ejecutable que se encuentra en la pesta\u00f1a \"Download\" de su p\u00e1gina web (enlace directo aqu\u00ed ). Una vez descargado, haciendo doble click sobre el archivo, lo ejecutaremos y proceder\u00e1 la instalaci\u00f3n del mismo. Durante la instalaci\u00f3n nos solicitar\u00e1 donde queremos guardar el directorio master , este es el directorio que contiene todas las herramientas que nos proporciona Easy2boot. El directorio que nos crea lo podemos utilizar para dejar todas las ISOS para crear tantos USB como queramos como veremos m\u00e1s adelante. Dentro del directorio nos podemos encontrar los siguientes ficheros: El \u00fanico directorio que nos encontramos dentro de Easy2boot es el llamado _ISO que es donde se almacenar\u00e1n todas nuestras im\u00e1genes. Como veremos a continuaci\u00f3n, estas im\u00e1genes estar\u00e1n agrupadas en subdirectorios, que corresponder\u00e1n a la tem\u00e1tica de cada iso. Esto es \u00fatil ya que el men\u00fa que nos muestra cuando arranquemos con el USB mostrar\u00e1 los subdirectorios que tengamos creados. Veamos los diferentes directorios que nos encontramos: ISOs de Sistemas Operativos (UEFI-BIOS) # Desde hace unos pocos a\u00f1os contamos con el denominado sistema UEFI, que es la versi\u00f3n que sustituye a la conocida BIOS. Para no entrar en detalles t\u00e9cnicos, dejamos un enlace a un medio ingl\u00e9s donde explican los beneficios que aporta UEFI respecto a BIOS UEFI, BIOS, GPT, MBR \u2013 What\u2019s the Difference? . Por este motivo, y para aprovechar esta caracter\u00edstica en los equipos m\u00e1s modernos, debemos tener en cuenta realizar instalaciones que nos permitan la compatibilidad con el modo UEFI. Es necesario modificar el fichero ISO con una herramienta que nos proporciona Easy2boot MPI tool kit . Adem\u00e1s de modificar las isos de los sistemas operativos, hay que modificar alg\u00fan autoarrancable como el de Hirens. A continuaci\u00f3n veremos los pasos necesarios para llevar a cabo la transformaci\u00f3n de las im\u00e1genes de los sistemas operativos. Una vez descargada la herramienta que hemos mencionado, debemos descomprimirla. Nos encontraremos dentro del directorio descomprimido con lo siguiente: El siguiente paso ser\u00e1 ir al directorio ImDisk y ejecutar el fichero imdiskinst.exe . Para facilitarnos el trabajo, crearemos varios accesos directos en el escritorio ejecutando el script que tenemos en el directorio principal de MPI toolkit. Este script se llama CreateDesktopShortcuts.cmd . A continuaci\u00f3n veremos que los accesos directos se habr\u00e1n creado directamente en nuestro escritorio. El \u00faltimo paso ser\u00e1 la creaci\u00f3n de la imagen con extensi\u00f3n .imgPTN . Para ello, en el directorio donde tengamos las diferentes ISOS de los sistemas operativos, arrastraremos estas im\u00e1genes al acceso directo creado en el escritorio, denominado MPI_FAT32 que ser\u00e1 la herramienta que har\u00e1 compatible nuestra imagen. Se abrir\u00e1 una ventana d Una vez creada la nueva imagen, la veremos en el mismo directorio donde se encuentra la \"original\". Surge un problema, y es que FAT32 no soporta ficheros de m\u00e1s de 4GB, y tanto la versi\u00f3n de Windows 8 de 64 bits como Windows 10 (32 y 64 bits) tienen un tama\u00f1o superior a 4GB. Para solucionar esto, Easy2boot nos proporciona varias opciones, que podemos encontrar en este enlace . Tal y como recomiendan en la web, se utilizar\u00e1 el m\u00e9todo 1. Dentro del directorio MPI Tool Kit nos encontramos con una herramienta llamada Win split winiso muy f\u00e1cil de utilizar. Bastar\u00e1 con ejecutarla, seleccionar la iso que tenga un tama\u00f1o superior a 4GB, establecer en 4000 en la opci\u00f3n Split Size y pulsar en convertir, tal y como vemos en la siguiente captura. Volcado USB # Una vez que tenemos preparado el directorio de Easy2boot con todos los pasos realizados anteriormente, procedemos a crear el Multiboot USB. Los pasos a seguir que veremos a continuaci\u00f3n son muy sencillos. Procedemos a ejecutar como administrador el script MAKE_E2B_USB_DRIVE . Se abrir\u00e1 una consola como administrador donde deberemos seleccionar el USB que queremos utilizar para el Multiboot. Una vez seleccionado el USB, seleccionaremos el tipo de formato de archivos. En este caso hemos seleccionado NTFS para que sea compatible con las ISO de Windows, ya que su tama\u00f1o supera los 4GB. Por \u00faltimo, nos saldr\u00e1 un aviso diciendo que el USB ser\u00e1 formateado y que todos los ficheros que contiene ser\u00e1n eliminados. Aceptamos y proceder\u00e1 la creaci\u00f3n del Multiboot. Dependiendo de la cantidad de ISOs tardar\u00e1 m\u00e1s o menos. \u00daltimos pasos # Un paso importante y que no debemos olvidar si queremos que nuestro USB funcione correctamente es desfragmentar la unidad con la herramienta que incorpora Easy2boot llamada Make this drive contiguous . Seg\u00fan lo que podemos leer en su web, en algunas ocasiones si no realizamos este paso es posible que nos salgan algunos warning cuando intentemos arrancar alguna ISO, por lo tanto para evitar dichos problemas ejecutaremos esta peque\u00f1a herramienta. \u00bfQu\u00e9 contiene el USB? # Herramientas: # Antivirus: Bitdefender rescue Kapersky Backup: Acronis True Image (Versi\u00f3n 2015 y 2016) Clonezilla Otras herramientas: GParted Live Systemrescue Hirens Boot Recover password Sistemas Operativos: # Windows: Windows 7 profesional (Versi\u00f3n 32 y 64 bits) Windows 8.1 profesional (Versi\u00f3n 32 y 64 bits) Windows 10 Profesional (64 bits) Windows 10 Home (64 bits) Linux: Linux Mint Cinnamon 19.1 CentOS Minimal 7 Consideraciones # La preparaci\u00f3n de este USB se puede realizar tambi\u00e9n en Linux. Los ficheros .imgPTN son compatibles tanto con MBR como con UEFI, por lo tanto todas las im\u00e1genes que tenemos (Linux y Windows) ser\u00e1n transformadas para tener compatibilidad con ambos ficheros. Los archivos descargados contienen ficheros Readme.txt , muy interesantes si queremos ampliar informaci\u00f3n sobre esta herramienta. Existe la posibilidad de personalizar el USB que hemos creado. Para ellosEasy2boot ha incorporado una herramienta gr\u00e1fica llamada E2B_Editor (es un fichero .exe ) que nos permite realizar diferentes configuraciones, como cambiar la imagen de fondo, los colores del men\u00fa, las opciones y un largo etc\u00e9tera. Fuentes # Easy2boot","title":"Easy2boot"},{"location":"Herramientas/Easy2boot/#easy2boot","text":"","title":"Easy2boot"},{"location":"Herramientas/Easy2boot/#introduccion","text":"Durante el desarrollo del proyecto hemos necesitado instalar diferentes sistemas operativos y arrancar equipos con herramientas booteables . Para ello hemos utilizado una herramienta muy potente, llamada Easy2boot . Esta magn\u00edfica herramienta nos permite introducir en un \u00fanico USB ISOS de diferentes sistemas operativos y herramientas como Hirens, GParted, etc. El l\u00edmite ser\u00e1 la capacidad de almacenamiento con la que cuenta nuestro USB. En este caso contamos con un USB de 32 GB, suficiente para tener varias ISOS de Windows y Linux, y adem\u00e1s contar con alguna herramienta de las mencionadas anteriormente. La creaci\u00f3n de este USB multiboot es bastante sencilla, hay una gu\u00eda en ingl\u00e9s bastante completa en su p\u00e1gina web . A pesar de ello, vamos a resumir el proceso que hemos seguido para crear este USB.","title":"Introducci\u00f3n"},{"location":"Herramientas/Easy2boot/#proceso-de-instalacion-easy2boot","text":"En primer lugar, necesitamos descargar el fichero ejecutable que se encuentra en la pesta\u00f1a \"Download\" de su p\u00e1gina web (enlace directo aqu\u00ed ). Una vez descargado, haciendo doble click sobre el archivo, lo ejecutaremos y proceder\u00e1 la instalaci\u00f3n del mismo. Durante la instalaci\u00f3n nos solicitar\u00e1 donde queremos guardar el directorio master , este es el directorio que contiene todas las herramientas que nos proporciona Easy2boot. El directorio que nos crea lo podemos utilizar para dejar todas las ISOS para crear tantos USB como queramos como veremos m\u00e1s adelante. Dentro del directorio nos podemos encontrar los siguientes ficheros: El \u00fanico directorio que nos encontramos dentro de Easy2boot es el llamado _ISO que es donde se almacenar\u00e1n todas nuestras im\u00e1genes. Como veremos a continuaci\u00f3n, estas im\u00e1genes estar\u00e1n agrupadas en subdirectorios, que corresponder\u00e1n a la tem\u00e1tica de cada iso. Esto es \u00fatil ya que el men\u00fa que nos muestra cuando arranquemos con el USB mostrar\u00e1 los subdirectorios que tengamos creados. Veamos los diferentes directorios que nos encontramos:","title":"Proceso de instalaci\u00f3n Easy2boot"},{"location":"Herramientas/Easy2boot/#isos-de-sistemas-operativos-uefi-bios","text":"Desde hace unos pocos a\u00f1os contamos con el denominado sistema UEFI, que es la versi\u00f3n que sustituye a la conocida BIOS. Para no entrar en detalles t\u00e9cnicos, dejamos un enlace a un medio ingl\u00e9s donde explican los beneficios que aporta UEFI respecto a BIOS UEFI, BIOS, GPT, MBR \u2013 What\u2019s the Difference? . Por este motivo, y para aprovechar esta caracter\u00edstica en los equipos m\u00e1s modernos, debemos tener en cuenta realizar instalaciones que nos permitan la compatibilidad con el modo UEFI. Es necesario modificar el fichero ISO con una herramienta que nos proporciona Easy2boot MPI tool kit . Adem\u00e1s de modificar las isos de los sistemas operativos, hay que modificar alg\u00fan autoarrancable como el de Hirens. A continuaci\u00f3n veremos los pasos necesarios para llevar a cabo la transformaci\u00f3n de las im\u00e1genes de los sistemas operativos. Una vez descargada la herramienta que hemos mencionado, debemos descomprimirla. Nos encontraremos dentro del directorio descomprimido con lo siguiente: El siguiente paso ser\u00e1 ir al directorio ImDisk y ejecutar el fichero imdiskinst.exe . Para facilitarnos el trabajo, crearemos varios accesos directos en el escritorio ejecutando el script que tenemos en el directorio principal de MPI toolkit. Este script se llama CreateDesktopShortcuts.cmd . A continuaci\u00f3n veremos que los accesos directos se habr\u00e1n creado directamente en nuestro escritorio. El \u00faltimo paso ser\u00e1 la creaci\u00f3n de la imagen con extensi\u00f3n .imgPTN . Para ello, en el directorio donde tengamos las diferentes ISOS de los sistemas operativos, arrastraremos estas im\u00e1genes al acceso directo creado en el escritorio, denominado MPI_FAT32 que ser\u00e1 la herramienta que har\u00e1 compatible nuestra imagen. Se abrir\u00e1 una ventana d Una vez creada la nueva imagen, la veremos en el mismo directorio donde se encuentra la \"original\". Surge un problema, y es que FAT32 no soporta ficheros de m\u00e1s de 4GB, y tanto la versi\u00f3n de Windows 8 de 64 bits como Windows 10 (32 y 64 bits) tienen un tama\u00f1o superior a 4GB. Para solucionar esto, Easy2boot nos proporciona varias opciones, que podemos encontrar en este enlace . Tal y como recomiendan en la web, se utilizar\u00e1 el m\u00e9todo 1. Dentro del directorio MPI Tool Kit nos encontramos con una herramienta llamada Win split winiso muy f\u00e1cil de utilizar. Bastar\u00e1 con ejecutarla, seleccionar la iso que tenga un tama\u00f1o superior a 4GB, establecer en 4000 en la opci\u00f3n Split Size y pulsar en convertir, tal y como vemos en la siguiente captura.","title":"ISOs de Sistemas Operativos (UEFI-BIOS)"},{"location":"Herramientas/Easy2boot/#volcado-usb","text":"Una vez que tenemos preparado el directorio de Easy2boot con todos los pasos realizados anteriormente, procedemos a crear el Multiboot USB. Los pasos a seguir que veremos a continuaci\u00f3n son muy sencillos. Procedemos a ejecutar como administrador el script MAKE_E2B_USB_DRIVE . Se abrir\u00e1 una consola como administrador donde deberemos seleccionar el USB que queremos utilizar para el Multiboot. Una vez seleccionado el USB, seleccionaremos el tipo de formato de archivos. En este caso hemos seleccionado NTFS para que sea compatible con las ISO de Windows, ya que su tama\u00f1o supera los 4GB. Por \u00faltimo, nos saldr\u00e1 un aviso diciendo que el USB ser\u00e1 formateado y que todos los ficheros que contiene ser\u00e1n eliminados. Aceptamos y proceder\u00e1 la creaci\u00f3n del Multiboot. Dependiendo de la cantidad de ISOs tardar\u00e1 m\u00e1s o menos.","title":"Volcado USB"},{"location":"Herramientas/Easy2boot/#ultimos-pasos","text":"Un paso importante y que no debemos olvidar si queremos que nuestro USB funcione correctamente es desfragmentar la unidad con la herramienta que incorpora Easy2boot llamada Make this drive contiguous . Seg\u00fan lo que podemos leer en su web, en algunas ocasiones si no realizamos este paso es posible que nos salgan algunos warning cuando intentemos arrancar alguna ISO, por lo tanto para evitar dichos problemas ejecutaremos esta peque\u00f1a herramienta.","title":"\u00daltimos pasos"},{"location":"Herramientas/Easy2boot/#que-contiene-el-usb","text":"","title":"\u00bfQu\u00e9 contiene el USB?"},{"location":"Herramientas/Easy2boot/#herramientas","text":"Antivirus: Bitdefender rescue Kapersky Backup: Acronis True Image (Versi\u00f3n 2015 y 2016) Clonezilla Otras herramientas: GParted Live Systemrescue Hirens Boot Recover password","title":"Herramientas:"},{"location":"Herramientas/Easy2boot/#sistemas-operativos","text":"Windows: Windows 7 profesional (Versi\u00f3n 32 y 64 bits) Windows 8.1 profesional (Versi\u00f3n 32 y 64 bits) Windows 10 Profesional (64 bits) Windows 10 Home (64 bits) Linux: Linux Mint Cinnamon 19.1 CentOS Minimal 7","title":"Sistemas Operativos:"},{"location":"Herramientas/Easy2boot/#consideraciones","text":"La preparaci\u00f3n de este USB se puede realizar tambi\u00e9n en Linux. Los ficheros .imgPTN son compatibles tanto con MBR como con UEFI, por lo tanto todas las im\u00e1genes que tenemos (Linux y Windows) ser\u00e1n transformadas para tener compatibilidad con ambos ficheros. Los archivos descargados contienen ficheros Readme.txt , muy interesantes si queremos ampliar informaci\u00f3n sobre esta herramienta. Existe la posibilidad de personalizar el USB que hemos creado. Para ellosEasy2boot ha incorporado una herramienta gr\u00e1fica llamada E2B_Editor (es un fichero .exe ) que nos permite realizar diferentes configuraciones, como cambiar la imagen de fondo, los colores del men\u00fa, las opciones y un largo etc\u00e9tera.","title":"Consideraciones"},{"location":"Herramientas/Easy2boot/#fuentes","text":"Easy2boot","title":"Fuentes"},{"location":"Herramientas/Github/","text":"GitHub Pages # Para dejar el contenido desarrollado p\u00fablico, hemos optado por utilizar la herramienta GitHub Pages que nos proporciona GitHub . \u00bfQu\u00e9 es GitHub? Es una web que implementa el control de versiones, y que permite mantener proyectos p\u00fablicos de forma gratuita alojados en dicha web. \u00bfQu\u00e9 es GitHub Pages? Es una herramienta sencilla que ofrece GitHub para alojar una p\u00e1gina web. Es similar a un servicio de hosting. GitHub Pages nos ofrece dos alternativas para la creaci\u00f3n de p\u00e1ginas web. GitHub account: en este caso s\u00f3lo disponemos de una \u00fanica p\u00e1gina web que va a asociada a nuestro nombre de usuario. Si nuestro nombre de usuarios es sfera , nuestra p\u00e1gina web deber\u00e1 ser sfera.github.io . Project Site: cuando hablamos de este tipo de webs, disponemos de sites ilimitados. Siguiendo con el ejemplo anterior, el dominio principal ser\u00e1 sfera.github.io , finalizando con /nombre_del_proyecto . Por lo tanto, si nuestro proyecto es tipstabet , el dominio completo ser\u00eda sfera.github.io/tipstabet . Hemos optador por crear un Project Site puesto que nos posibilita en el futuro crear m\u00e1s p\u00e1ginas web de diferentes proyectos. Note El dominio de nuestra p\u00e1gina web se puede personalizar. Podemos seguir este enlace donde se explica como realizar este proceso. Iniciando la implementaci\u00f3n # Durante el proyecto la documentaci\u00f3n se ha implementado con la herramienta MkDocs . Se ha desarrollado de forma local en una Raspberry pi y utilizando dicho dispositivo para alojarlo en su servidor Nginx . Para publicarlo en GitHub disponemos de dos opciones, una siguiendo esta gu\u00eda conservando el tema utilizado inicialmente ( Read the Docs ), y otra segunda opci\u00f3n utilizando el tema Material for MkDocs . Finalmente hemos decidido cambiar a esta segunda opci\u00f3n puesto que dispone de mayores configuraciones a trav\u00e9s del fichero mkdocs.yml y una mejor adaptaci\u00f3n visual en los diferentes dispsitivos. Las herramientas utilizadas para llevar a cabo este proceso han sido varias. Por un lado hemos utilizado Docker para realizar diversas pruebas y llevar a cabo la implementaci\u00f3n final, y por otro lado Git como herramienta de Control de Versiones . Ambas herramientas se encuentran disponibles para las principales plataformas (Linux, Windows y MacOS). Para esta parte del proyecto hemos utilizado un equipo con Sistema Operativo MacOS . Instalaci\u00f3n de Docker en MacOS Instalaci\u00f3n de Git en MacOS Git # Es la herramienta de Control de Versiones por excelencia. En el partado anterior hemos puesto un enlace donde encontraremos las gu\u00edas para la instalaci\u00f3n en las diferentes plataformas en las que se encuentra disponible. En primer lugar comprobaremos que tenemos Git instalado en nuestro sistema. 1 git --version Una vez que verificamos que tenemos instalado procederemos a realizar las configuraciones globales, estableciendo un nombre de usuario y una cuenta de email que quedar\u00e1n registradas cuando realicemos alg\u00fan cambio en el repositorio. Configuraci\u00f3n del nombre de usuario 1 git config --global user.name \"nombre\" Configuraci\u00f3n del email 1 git config --global user.email \"email\" Listar los par\u00e1metros que hemos configurado 1 git config --list La forma de trabajar de Git es rastreando el Working Directory en busca de cambios que se hayan realizado, para ello es necesario indicarle que directorio tiene que rastrear. El comando para indicar a Git que queremos rastrear un directorio es el siguiente (debemos estar situados dentro del directorio que queremos que actue como Working Directory ): 1 git init Si ejecutamos el comando ls -la veremos que aparece un directorio oculto denominado .git/ , esto significa que se ha iniciado git correctamente. En el directorio que hemos iniciado git nos encontramos con lo siguiente: Directorio con la documentaci\u00f3n Fichero mkdcos.yml Directorio /site que contiene todos los ficheros generados por MkDcos para mostrar como p\u00e1gina web. Todo lo anterior no queremos que se muestre en la rama principal de nuestro repositorio (branch/rama master). Git nos proporiciona una forma f\u00e1cil de solucionarlo, un fichero denominado .gitignore que nos permite incluir tanto ficheros como directorios del Working Directory sobre los que no queremos que git lleve un control. A continuaci\u00f3n podemos ver que hemos incluido dentro de este fichero. 1 2 3 4 5 6 7 #MacOS .DS_Store #Site to build /site /docs mkdocs.yml Nos quedan dos \u00faltimos pasos, a\u00f1adir el repositorio remote y subir los ficheros que pertenecen a la rama master. 1 2 3 4 5 #A\u00f1adimos el repositorio remoto git remote add origin repositorio_remoto #Realizamos el commit sobre los ficheros de la rama master git commit -am \"Comentario\" Note repositorio_remoto es la direcci\u00f3n que nos proporicona GitHub en formato ssh para conectarnos a \u00e9l. Es necesario configurar ssh . Docker # Para implementar GitHub lo vamos a hacer a trav\u00e9s de Docker. El desarrollador de este tema tiene un contenedor en el repositorio de Docker ( Docker Hub ) que facilita todo el proceso para subir el contenido a nuestro repositorio remoto. En apartados anteriores hemos dejado un enlace a la instalaci\u00f3n de Docker en MacOS. El proceso es muy sencillo, y al igual que sucede con Git podemos verificar si est\u00e1 correctamente instalado ejecutando el siguiente comando: 1 docker --version No vamos a entrar a ver con detalle el funcionamiento de Docker, es un servicio con multitud de opciones y comandos. La documentaci\u00f3n oficial es muy amplia y podemos encontrar informaci\u00f3n y gu\u00edas sobre pr\u00e1cticamente todo lo que engloba Docker. Vamos a desglosar \u00fanicamente el comando que debemos ejecutar para poner en marcha nuestro proyecto. El comando es el siguiente: 1 docker run --rm -it -v ~/.ssh:/root/.ssh -v ~/.gitconfig:/root/.gitconfig ~/tipstabet:/docs squidfunk/mkdocs-material gh-deploy -m \"Comentario\" docker run: comando utilizado para crear contenedores a partir de una imagen. --rm: comprueba si existe el mismo contenedor, y si es as\u00ed lo elimina. -it: los contenedores necesitan una capa llamada CMD para que el contenedor pueda funcionar. Otra forma de hacerlo es con esta opci\u00f3n, que mantiene una tty interactiva. -v: hace referencia a los vol\u00famenes de Docker. Su cometido (en este caso) es compartir ficheros de la m\u00e1quina anfitri\u00f3n con el contenedor. La ruta que se establece al a izquierda de los : es la de nuestra m\u00e1quina local, y a su derecha es la ruta dentro del contenedor en Docker. squidfunk/mkdocs: es la imagen utilizada. En caso de que no la tengamos descargada previamente, la ejecuci\u00f3n del comando docker run se demorar\u00e1 porque la descargar\u00e1. ~/.gitconfig:/root/.gitconfig : permite mostrar el usuario que ha hecho el commit. ~/tipstabet:/docs: la ruta donde se encuentra la documentaci\u00f3n en nuestra m\u00e1quina. ~/.ssh:/root/.ssh: la ruta donde se encuentra almacenada nuestras llaves ssh.donde. gh-deploy : es una utilidad para realizar la implementaci\u00f3n directa con GitHub. En este enlace podemos encontrar m\u00e1s informaci\u00f3n sobre esta herramienta. -m \"Comentario\" : permite personalizar el comentario del commit. Note gh-deploy crea una rama nueva llamada gh-pages que es la que utiliza GitHub como hosting para despu\u00e9s poder visualizar la p\u00e1gina web correctamente. Con lo cual tendremos dos ramas, la rama master donde se encontrar\u00e1 el fichero .gitignore que hemos explicado anteriormente, y el fichero README.md que explica en que consiste el repositorio.","title":"GitHub Deployment"},{"location":"Herramientas/Github/#github-pages","text":"Para dejar el contenido desarrollado p\u00fablico, hemos optado por utilizar la herramienta GitHub Pages que nos proporciona GitHub . \u00bfQu\u00e9 es GitHub? Es una web que implementa el control de versiones, y que permite mantener proyectos p\u00fablicos de forma gratuita alojados en dicha web. \u00bfQu\u00e9 es GitHub Pages? Es una herramienta sencilla que ofrece GitHub para alojar una p\u00e1gina web. Es similar a un servicio de hosting. GitHub Pages nos ofrece dos alternativas para la creaci\u00f3n de p\u00e1ginas web. GitHub account: en este caso s\u00f3lo disponemos de una \u00fanica p\u00e1gina web que va a asociada a nuestro nombre de usuario. Si nuestro nombre de usuarios es sfera , nuestra p\u00e1gina web deber\u00e1 ser sfera.github.io . Project Site: cuando hablamos de este tipo de webs, disponemos de sites ilimitados. Siguiendo con el ejemplo anterior, el dominio principal ser\u00e1 sfera.github.io , finalizando con /nombre_del_proyecto . Por lo tanto, si nuestro proyecto es tipstabet , el dominio completo ser\u00eda sfera.github.io/tipstabet . Hemos optador por crear un Project Site puesto que nos posibilita en el futuro crear m\u00e1s p\u00e1ginas web de diferentes proyectos. Note El dominio de nuestra p\u00e1gina web se puede personalizar. Podemos seguir este enlace donde se explica como realizar este proceso.","title":"GitHub Pages"},{"location":"Herramientas/Github/#iniciando-la-implementacion","text":"Durante el proyecto la documentaci\u00f3n se ha implementado con la herramienta MkDocs . Se ha desarrollado de forma local en una Raspberry pi y utilizando dicho dispositivo para alojarlo en su servidor Nginx . Para publicarlo en GitHub disponemos de dos opciones, una siguiendo esta gu\u00eda conservando el tema utilizado inicialmente ( Read the Docs ), y otra segunda opci\u00f3n utilizando el tema Material for MkDocs . Finalmente hemos decidido cambiar a esta segunda opci\u00f3n puesto que dispone de mayores configuraciones a trav\u00e9s del fichero mkdocs.yml y una mejor adaptaci\u00f3n visual en los diferentes dispsitivos. Las herramientas utilizadas para llevar a cabo este proceso han sido varias. Por un lado hemos utilizado Docker para realizar diversas pruebas y llevar a cabo la implementaci\u00f3n final, y por otro lado Git como herramienta de Control de Versiones . Ambas herramientas se encuentran disponibles para las principales plataformas (Linux, Windows y MacOS). Para esta parte del proyecto hemos utilizado un equipo con Sistema Operativo MacOS . Instalaci\u00f3n de Docker en MacOS Instalaci\u00f3n de Git en MacOS","title":"Iniciando la implementaci\u00f3n"},{"location":"Herramientas/Github/#git","text":"Es la herramienta de Control de Versiones por excelencia. En el partado anterior hemos puesto un enlace donde encontraremos las gu\u00edas para la instalaci\u00f3n en las diferentes plataformas en las que se encuentra disponible. En primer lugar comprobaremos que tenemos Git instalado en nuestro sistema. 1 git --version Una vez que verificamos que tenemos instalado procederemos a realizar las configuraciones globales, estableciendo un nombre de usuario y una cuenta de email que quedar\u00e1n registradas cuando realicemos alg\u00fan cambio en el repositorio. Configuraci\u00f3n del nombre de usuario 1 git config --global user.name \"nombre\" Configuraci\u00f3n del email 1 git config --global user.email \"email\" Listar los par\u00e1metros que hemos configurado 1 git config --list La forma de trabajar de Git es rastreando el Working Directory en busca de cambios que se hayan realizado, para ello es necesario indicarle que directorio tiene que rastrear. El comando para indicar a Git que queremos rastrear un directorio es el siguiente (debemos estar situados dentro del directorio que queremos que actue como Working Directory ): 1 git init Si ejecutamos el comando ls -la veremos que aparece un directorio oculto denominado .git/ , esto significa que se ha iniciado git correctamente. En el directorio que hemos iniciado git nos encontramos con lo siguiente: Directorio con la documentaci\u00f3n Fichero mkdcos.yml Directorio /site que contiene todos los ficheros generados por MkDcos para mostrar como p\u00e1gina web. Todo lo anterior no queremos que se muestre en la rama principal de nuestro repositorio (branch/rama master). Git nos proporiciona una forma f\u00e1cil de solucionarlo, un fichero denominado .gitignore que nos permite incluir tanto ficheros como directorios del Working Directory sobre los que no queremos que git lleve un control. A continuaci\u00f3n podemos ver que hemos incluido dentro de este fichero. 1 2 3 4 5 6 7 #MacOS .DS_Store #Site to build /site /docs mkdocs.yml Nos quedan dos \u00faltimos pasos, a\u00f1adir el repositorio remote y subir los ficheros que pertenecen a la rama master. 1 2 3 4 5 #A\u00f1adimos el repositorio remoto git remote add origin repositorio_remoto #Realizamos el commit sobre los ficheros de la rama master git commit -am \"Comentario\" Note repositorio_remoto es la direcci\u00f3n que nos proporicona GitHub en formato ssh para conectarnos a \u00e9l. Es necesario configurar ssh .","title":"Git"},{"location":"Herramientas/Github/#docker","text":"Para implementar GitHub lo vamos a hacer a trav\u00e9s de Docker. El desarrollador de este tema tiene un contenedor en el repositorio de Docker ( Docker Hub ) que facilita todo el proceso para subir el contenido a nuestro repositorio remoto. En apartados anteriores hemos dejado un enlace a la instalaci\u00f3n de Docker en MacOS. El proceso es muy sencillo, y al igual que sucede con Git podemos verificar si est\u00e1 correctamente instalado ejecutando el siguiente comando: 1 docker --version No vamos a entrar a ver con detalle el funcionamiento de Docker, es un servicio con multitud de opciones y comandos. La documentaci\u00f3n oficial es muy amplia y podemos encontrar informaci\u00f3n y gu\u00edas sobre pr\u00e1cticamente todo lo que engloba Docker. Vamos a desglosar \u00fanicamente el comando que debemos ejecutar para poner en marcha nuestro proyecto. El comando es el siguiente: 1 docker run --rm -it -v ~/.ssh:/root/.ssh -v ~/.gitconfig:/root/.gitconfig ~/tipstabet:/docs squidfunk/mkdocs-material gh-deploy -m \"Comentario\" docker run: comando utilizado para crear contenedores a partir de una imagen. --rm: comprueba si existe el mismo contenedor, y si es as\u00ed lo elimina. -it: los contenedores necesitan una capa llamada CMD para que el contenedor pueda funcionar. Otra forma de hacerlo es con esta opci\u00f3n, que mantiene una tty interactiva. -v: hace referencia a los vol\u00famenes de Docker. Su cometido (en este caso) es compartir ficheros de la m\u00e1quina anfitri\u00f3n con el contenedor. La ruta que se establece al a izquierda de los : es la de nuestra m\u00e1quina local, y a su derecha es la ruta dentro del contenedor en Docker. squidfunk/mkdocs: es la imagen utilizada. En caso de que no la tengamos descargada previamente, la ejecuci\u00f3n del comando docker run se demorar\u00e1 porque la descargar\u00e1. ~/.gitconfig:/root/.gitconfig : permite mostrar el usuario que ha hecho el commit. ~/tipstabet:/docs: la ruta donde se encuentra la documentaci\u00f3n en nuestra m\u00e1quina. ~/.ssh:/root/.ssh: la ruta donde se encuentra almacenada nuestras llaves ssh.donde. gh-deploy : es una utilidad para realizar la implementaci\u00f3n directa con GitHub. En este enlace podemos encontrar m\u00e1s informaci\u00f3n sobre esta herramienta. -m \"Comentario\" : permite personalizar el comentario del commit. Note gh-deploy crea una rama nueva llamada gh-pages que es la que utiliza GitHub como hosting para despu\u00e9s poder visualizar la p\u00e1gina web correctamente. Con lo cual tendremos dos ramas, la rama master donde se encontrar\u00e1 el fichero .gitignore que hemos explicado anteriormente, y el fichero README.md que explica en que consiste el repositorio.","title":"Docker"},{"location":"Herramientas/Rclone/","text":"Rclone # \u00bfQu\u00e9 es Rclone? # Es una herramienta muy potente para interactuar con servicios en la nube. Esta herramienta se utiliza desde la l\u00ednea de comandos, y nos permite trabajar principalmente de tres modos diferentes. Rclone sync: para la sincronizaci\u00f3n hac\u00eda o desde los servicios en la nube. Rclone copy: para el copiado hac\u00eda o desde los servicios en la nube. La diferencia respecto a sync es que a pesar de que se eliminen algunos ficheros, en el dispositivo cliente (donde hemos realizado la copia) esos fichero eliminados nos desaparecer\u00e1n, puesto que no est\u00e1n sincronizados. Rclone mount : para el montaje de servicios en la nube en nuestro dispositivos. Tal y como realiza el comando mount en Linux, nos permite montar una unidad de los servicios en la nube compatibles, como si se tratase de un sistema de ficheros de nuestro dispositivo. Hay una larga lista de servicios compatibles con esta herramienta, los podemos consultar en este enlace . Instalaci\u00f3n: # Como ya se ha comentado, el Sistema Operativo Rockstor est\u00e1 m\u00e1s limitado que otros Sistemas orientados a NAS, en lo referente a Docker. Por lo tanto no podremos instalar esta herramienta como contenedor, por lo que haremos la instalaci\u00f3n dentro del propio Sistema desde la l\u00ednea de comandos. La instalaci\u00f3n es muy sencilla, en esta web podemos ver la instalaci\u00f3n tanto para Linux como para MacOS. Podemos optar por llamar a un script que realizar\u00e1 todo el proceso de instalaci\u00f3n, o descargarnos un fichero .zip que descomprimiremos e instalaremos. Un aspecto importante a tener en cuenta es que siguiendo la gu\u00eda de instalaci\u00f3n sobre Linux, no descarga la \u00faltima versi\u00f3n. Para evitar esto, y descargar la \u00faltima versi\u00f3n, iremos a este enlace y copiaremos la direcci\u00f3n del fichero .zip que corresponde con nuestra m\u00e1quina. Los siguientes puntos sobre como debemos instalar esta herramienta est\u00e1n copiados directamente desde la web de rclone. Descarga del fichero .zip y descompresi\u00f3n. 1 2 3 curl -O https://downloads.rclone.org/v1.47.0/rclone-v1.47.0-linux-amd64.zip unzip rclone-v1.47.0-linux-amd64.zip cd rclone-v1.47.0-linux-amd64 Note La ruta que debemos poner es la que corresponde a la \u00faltima versi\u00f3n de Rclone. Trasladar el binario rclone . 1 2 3 sudo cp rclone /usr/bin/ sudo chown root:root /usr/bin/rclone sudo chmod 755 /usr/bin/rclone Note La ruta /usr/bin se encuentra en el PATH, que es la variable que contiene las rutas a los directorios que contienen los ficheros ejecutables. De ese modo podremos ejecutar Rclone sin importar en que directorio del sistema nos encontremos. A\u00f1adiendo el manual de rclone a la base de datos de manuales. 1 2 3 sudo mkdir -p /usr/local/share/man/man1 sudo cp rclone.1 /usr/local/share/man/man1/ sudo mandb Note La herramienta unzip no se encuentra instalada, para instalarla es suficiente con ejecutar yum install unzip . Copiamos el manual y actualizamos la base de datos de los manuales para que podamos invocar el \"man page\" ejecutando man rclone . Configuraci\u00f3n: # La configuraci\u00f3n es muy sencilla ya que el propia sistema nos gu\u00eda una vez que ejecutamos rclone config . Cuando ejecutamos este comando nos aparecer\u00e1 un peque\u00f1o men\u00fa desde donde crearemos los nuevos servicios remotos. La opci\u00f3n para crear es la \" n \", que una vez seleccionada esta opci\u00f3n nos aparecer\u00e1 en el prompt para asignarle un nombre, y a continuaci\u00f3n debemos elegir que servicio queremos configurar. Hemos seleccionado Google Drive que es la opci\u00f3n n\u00famero 12 (quiz\u00e1 pueda variar de el n\u00famero si la versi\u00f3n de Rclone es diferente). Nos aparecer\u00e1n una serie de par\u00e1metros para ir configurando, \u00fanicamente mostrar\u00e9 los que hemos necesitado configurar, puesto que el resto se han dejado por defecto ya que los valores por defecto eran suficientes tal y como indica la gu\u00eda de rclone. En uno de los pasos de la configuraci\u00f3n debemos establecer los permisos que le otorgamos, para lo que necesitamos la opci\u00f3n n\u00famero \"1\" es la m\u00e1s adecuada, siendo esta la m\u00e1s permisiva. A continuaci\u00f3n, si no queremos que rclone tenga acceso a todos los directorios que tenemos en nuestra cuenta de Google Drive, debemos especificar cual ser\u00e1 el directorio root. La mejor forma de hacerlo es copiar y pegar la parte final de la url que nos aparece cuando estamos en el directorio que queremos que rclone tenga acceso. y Otra de las preguntas que nos aparecer\u00e1n es si deseamos editar la configuraci\u00f3n avanzada, para nuestro supuesto no es necesario, por lo que seleccionaremos \" n \". La siguiente cuesti\u00f3n a tener en cuenta es si deseamos utilizar la configuraci\u00f3n autom\u00e1tica. Como podemos ver en la explicaci\u00f3n, en el segundo punto nos indica que s\u00ed estamos trabajando en una m\u00e1quina remota (por ejemplo contra nuestro servidor v\u00eda ssh) debemos seleccionar la opci\u00f3n \" n \", que ser\u00e1 la opci\u00f3n que seleccionaremos. Al haber pulsado la opci\u00f3n \" n \" nos mostrar\u00e1 una direcci\u00f3n que debemos copiar y pegar en nuestro navegador. Esta direcci\u00f3n nos solicitar\u00e1 autenticarnos con la cuenta de Google Drive que queremos vincular con Rclone. Una vez que nos autentiquemos nos aparecer\u00e1 un c\u00f3digo que copiaremos y pegaremos en la l\u00ednea que nos solicita Rclone. Antes de finalizar, nos preguntar\u00e1 si deseamos configurar como un Team Drive [^1], no es nuestro caso por lo tanto seleccionaremos \" n \". Nos mostrar\u00e1 un peque\u00f1o resumen con el \" remote \" que hemos configurado. Para finalizar debemos seleccionar con la letra \" q \" (Quit config). Opciones utilizadas: # Nuestro objetivo es sincronizar el directorio al que hemos dado acceso a rclone con un directorio que tenemos en nuestro NAS. Como ya hemos hablado en la primera parte, para la sincronizaci\u00f3n hemos utilizado el comando rclone sync . Para el correcto funcionamiento hemos hecho uso de varios par\u00e1metros/flags que se explicar\u00e1n a continuaci\u00f3n. Logging # Utilizaremos dos opciones para monitorizar rclone. -v, --verbose : rclone tiene 4 niveles de log, ERROR , AVISO , INFO Y DEBUG . Cuando utilizamos -v , rclone muestra los tres primeros niveles de error. --log-file=FILE : en combinaci\u00f3n con la anterior, todo el log monitorizado lo enviamos a un fichero, que ser\u00e1 el que establecemos despu\u00e9s del s\u00edmbolo = . Bwlimit # --bwlimit : con est\u00e1 opci\u00f3n limitamos el ancho de banda. En nuestro caso la utilizaremos para no ocupar todo el ancho de banda que nos proporciona nuestro ISP. Por la web se puede ver limitaciones de 8650k (Hace referencia a 8650 KBytes, que si hacemos la operaci\u00f3n matem\u00e1tica correspondiente son aproximadamente 750GB diarios, que es el limite para los Team Drive enlace m\u00e1s abajo ). Seg\u00fan lo que se puede leer por algunas consultas realizadas al soporte de Google, no hay limitaciones, salvo en los que se refiere a contenido de video (Por ejemplo si queremos utilizar GD para almac\u00e9n del contenido de Plex) y de hosting. Limitaciones de Google: Files you can store in Google Drive Team Drive Limits ; After you've uploaded 750 GB to a Team Drive in 1 day, you'll be blocked from uploading additional files that day. However, file uploads already in progress will complete, up to a 5 TB maximum for a single file. Update # -u, --update : con esta opci\u00f3n obligamos a rclone que omita cualquier archivo que tenga una hora de modificaci\u00f3n m\u00e1s reciente en destino que en origen. Adem\u00e1s, si el archivo tiene la misma hora de modificaci\u00f3n en destino como en origen, s\u00f3lo se actualizar\u00e1 si el tama\u00f1o es diferente. Tpslimit # --tpslmit : debido a los baneos de las cuentas de google drive (los baneos son de 24 horas, que es el tiempo que tarde Google en refrescar las estad\u00edsticas , desconozco si los baneos son mayores si el baneo es reiterado). Seg\u00fan lo que he podido leer en varios grupos de telegram y por internet, la cifra m\u00e1s acertada es 8, que son el n\u00famero de peticiones m\u00e1ximas por segundo que har\u00edamos a la API de Google. Transfers # --transfers : es el n\u00famero de transferencias en paralelo que se realizan. Por defecto rclone establece 4 transferencias en paralelo. Puesto que me parece un n\u00famero excesivamente bajo, y aprovechando el ancho de banda que le hemos dados, vamos a elevar el n\u00famero a 15. Estas son las opciones que hemos necesitado introducir para que la sincronizaci\u00f3n funcione correctamente. Lo que pretendemos es una sincronizaci\u00f3n y con la ejecuci\u00f3n de rclone sync en una ocasi\u00f3n no conseguiremos la sincronizaci\u00f3n indefinida, la sincronizaci\u00f3n se completa cada vez que este comando se ejecuta, por lo tanto para facilitar esto haremos uso de dos peque\u00f1os scripts. Script 1: 1 2 3 #!/bin/bash rclone sync ASIR: /sharedfolders/ASIRDrive -v --log-file = /home/Logs/rclonesync.txt -u --bwlimit 8650k --tpslimit 10 --transfers 15 exit Script 2: 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash #Comprobamos que el script no se est\u00e1 ejecutando mediante pidof if pidof -o %PPID -x sh /home/Scripts/rclonesync.sh ; then exit 1 fi #Despu\u00e9s de comprobar, si no se est\u00e1 ejecutando pasar\u00e1 a ejecutar los siguientes comandos. echo \"Ejecutando rclonesync...\" #Puesto que la ruta de los scripts no se encuentra en la variable PATH es neceario indicarle la ruta completa. Esto ejecutar\u00e1 el \"Script 1\" /home/Scripts/rclonesync.sh echo \"\u00a1La ejecuci\u00f3n del script ha finalizado!\" exit Note La ruta que establecida despu\u00e9s de sh puede diferir con la que utilic\u00e9is. Ten\u00e9is que indicar la ruta donde se encuentra vuestro script. Una vez que hemos creado los Scripts en el directorio de Rclone que hayamos decidido, les daremos permiso de ejecuci\u00f3n para que no sea necesario llamar al comando sh y con poner la ruta completa del script sea suficiente. Esto nos evitar\u00e1 algunos problemas que pueden surgir con el comando pidof. 1 chmod a + x / home / Scripts /* a+x: otorgamos permisos ejecuci\u00f3n a todos los usuarios. /home/Scripts/*: a todo el contenido que se encuentra en esta ruta. Ya tenemos los scripts que queremos ejecutar para controlar de una forma m\u00e1s sencilla la sincronizaci\u00f3n, pero nos falta configurar que el sistema ejecute estos scripts autom\u00e1ticamente. \u00bfQu\u00e9 necesitamos? Como hemos hecho en otras ocasiones, haremos uso del programador de trabajos de Linux, es decir, de cron. Rockstor est\u00e1 limitado para crear tareas planificadas desde la interfaz web, \u00fanicamente nos permite crear varias tareas ya planificadas por el sistema, y no las nuestras propias. Una vez m\u00e1s debemos hacer uso de la l\u00ednea de comandos, utilizaremos el comando crontab para a\u00f1adir la ejecuci\u00f3n del \"Script 2\" cada 30 minutos . 1 2 3 4 5 #Abrimos el editor de cron crontab -e #A\u00f1adimos la tarea */30 * * * * /home/Scripts/comprobar_rclonesync.sh Control de Logs # Por la web de Rclone no se menciona nada sobre el control del tama\u00f1o de los log que se van generando. Ser\u00eda interesante poder eliminar los datos antiguos, es decir establecer un l\u00edmite de por ejemplo 10MB y cuando llegue a ese l\u00edmite que vaya eliminando logs antiguos para poder introducir nuevos logs. Como digo, no he visto forma de hacerlo por lo tanto voy a a\u00f1adir a cron un comando a ejecutar para que compruebe el tama\u00f1o de los logs y en caso de que supere el tama\u00f1o que nosotros le indiquemos (en nuestro caso ser\u00e1n 10MB) que realice una acci\u00f3n. 1 find /home/Logs/ -type f -size +10M -exec rm -f {} \\; find: comando utilizado para realizar b\u00fasquedas. /home/Logs/: es la ruta en la que queremos buscar, podemos indicarle la que queramos. La ruta que he marcado es donde se encuentran los Logs de rclone. -type f: es el tipo de fichero que queremos buscar (en linux todo es un fichero), en nuestro caso ser\u00e1 un fichero de tipo file . -size +10M: buscamos fichero mayor de 10 Megabytes. Si delante del 10 indicamos un - buscar\u00e1 ficheros menores a 10 Megabytes. Se puede establecer otras unidades de medida que se encuentran explicadas en el manual de find. -exec: nos permite ejecutar una acci\u00f3n con todo aquello que ha encontrado (en funci\u00f3n de las condiciones que le hemos marcado). rm -f: rm = remove, es decir elimina lo que hemos encontrado, y como estamos seguros de que lo que ha encontrado lo queremos eliminar pasamos el par\u00e1metro -f para que no nos solicite confirmaci\u00f3n. {}: identifica a todo lo que ha encontrado el comando find. \\;: es la finalizaci\u00f3n del comando find cuando utilizamos la opci\u00f3n -excec . Man find Otros comandos \u00fatiles: # Listremotes: nos permite listar todos los remotes que hemos configurado. 1 rclone listremotes List : nos permite listar el contenido. Hay varios comandos que podemos ejecutar que nos mostrar\u00e1n diferentes resultados. 1 2 3 4 5 6 7 8 #Lista los objetos que se encuentran en REMOTO. rclone ls REMOTO: #Lista los directorios que se encuentra en REMOTO con fecha y hora de creaci\u00f3n. rclone lsd REMOTO: #Lista todo el contenido de la ruta que le indiques, tanto directorios como ficheros. rclone lsf REMOTO: #Lista todo el contenido (ficheros y directorios) incluido lo que se encuentra en todas las subcarpetas. rclone lsl REMOTO: Tree : nos muestra un lista de todo el contenido en forma de \u00e1rbol. (No lo recomiendo utilizar ya que tarda bastante en ejecutarse) . 1 rclone tree REMOTO: Help: nos permite ver diferentes comandos o flags que podemos introducir. 1 2 3 rclone --help rclone help flags rclone help backends Note Donde aparece REMOTO es necesario sustituirlo por el nombre de la unidad que hay\u00e1is configurado. Enlaces interesantes: # \u00bfQu\u00e9 son las unidades de equipos (Team Drive)? Funcionamiento de logging en rclone M\u00e1s filtros de Rclone Google OAuth \u201cinvalid_grant\u201d nightmare\u200a\u2014\u200aand how to fix it Rclone commands","title":"Rclone"},{"location":"Herramientas/Rclone/#rclone","text":"","title":"Rclone"},{"location":"Herramientas/Rclone/#que-es-rclone","text":"Es una herramienta muy potente para interactuar con servicios en la nube. Esta herramienta se utiliza desde la l\u00ednea de comandos, y nos permite trabajar principalmente de tres modos diferentes. Rclone sync: para la sincronizaci\u00f3n hac\u00eda o desde los servicios en la nube. Rclone copy: para el copiado hac\u00eda o desde los servicios en la nube. La diferencia respecto a sync es que a pesar de que se eliminen algunos ficheros, en el dispositivo cliente (donde hemos realizado la copia) esos fichero eliminados nos desaparecer\u00e1n, puesto que no est\u00e1n sincronizados. Rclone mount : para el montaje de servicios en la nube en nuestro dispositivos. Tal y como realiza el comando mount en Linux, nos permite montar una unidad de los servicios en la nube compatibles, como si se tratase de un sistema de ficheros de nuestro dispositivo. Hay una larga lista de servicios compatibles con esta herramienta, los podemos consultar en este enlace .","title":"\u00bfQu\u00e9 es Rclone?"},{"location":"Herramientas/Rclone/#instalacion","text":"Como ya se ha comentado, el Sistema Operativo Rockstor est\u00e1 m\u00e1s limitado que otros Sistemas orientados a NAS, en lo referente a Docker. Por lo tanto no podremos instalar esta herramienta como contenedor, por lo que haremos la instalaci\u00f3n dentro del propio Sistema desde la l\u00ednea de comandos. La instalaci\u00f3n es muy sencilla, en esta web podemos ver la instalaci\u00f3n tanto para Linux como para MacOS. Podemos optar por llamar a un script que realizar\u00e1 todo el proceso de instalaci\u00f3n, o descargarnos un fichero .zip que descomprimiremos e instalaremos. Un aspecto importante a tener en cuenta es que siguiendo la gu\u00eda de instalaci\u00f3n sobre Linux, no descarga la \u00faltima versi\u00f3n. Para evitar esto, y descargar la \u00faltima versi\u00f3n, iremos a este enlace y copiaremos la direcci\u00f3n del fichero .zip que corresponde con nuestra m\u00e1quina. Los siguientes puntos sobre como debemos instalar esta herramienta est\u00e1n copiados directamente desde la web de rclone. Descarga del fichero .zip y descompresi\u00f3n. 1 2 3 curl -O https://downloads.rclone.org/v1.47.0/rclone-v1.47.0-linux-amd64.zip unzip rclone-v1.47.0-linux-amd64.zip cd rclone-v1.47.0-linux-amd64 Note La ruta que debemos poner es la que corresponde a la \u00faltima versi\u00f3n de Rclone. Trasladar el binario rclone . 1 2 3 sudo cp rclone /usr/bin/ sudo chown root:root /usr/bin/rclone sudo chmod 755 /usr/bin/rclone Note La ruta /usr/bin se encuentra en el PATH, que es la variable que contiene las rutas a los directorios que contienen los ficheros ejecutables. De ese modo podremos ejecutar Rclone sin importar en que directorio del sistema nos encontremos. A\u00f1adiendo el manual de rclone a la base de datos de manuales. 1 2 3 sudo mkdir -p /usr/local/share/man/man1 sudo cp rclone.1 /usr/local/share/man/man1/ sudo mandb Note La herramienta unzip no se encuentra instalada, para instalarla es suficiente con ejecutar yum install unzip . Copiamos el manual y actualizamos la base de datos de los manuales para que podamos invocar el \"man page\" ejecutando man rclone .","title":"Instalaci\u00f3n:"},{"location":"Herramientas/Rclone/#configuracion","text":"La configuraci\u00f3n es muy sencilla ya que el propia sistema nos gu\u00eda una vez que ejecutamos rclone config . Cuando ejecutamos este comando nos aparecer\u00e1 un peque\u00f1o men\u00fa desde donde crearemos los nuevos servicios remotos. La opci\u00f3n para crear es la \" n \", que una vez seleccionada esta opci\u00f3n nos aparecer\u00e1 en el prompt para asignarle un nombre, y a continuaci\u00f3n debemos elegir que servicio queremos configurar. Hemos seleccionado Google Drive que es la opci\u00f3n n\u00famero 12 (quiz\u00e1 pueda variar de el n\u00famero si la versi\u00f3n de Rclone es diferente). Nos aparecer\u00e1n una serie de par\u00e1metros para ir configurando, \u00fanicamente mostrar\u00e9 los que hemos necesitado configurar, puesto que el resto se han dejado por defecto ya que los valores por defecto eran suficientes tal y como indica la gu\u00eda de rclone. En uno de los pasos de la configuraci\u00f3n debemos establecer los permisos que le otorgamos, para lo que necesitamos la opci\u00f3n n\u00famero \"1\" es la m\u00e1s adecuada, siendo esta la m\u00e1s permisiva. A continuaci\u00f3n, si no queremos que rclone tenga acceso a todos los directorios que tenemos en nuestra cuenta de Google Drive, debemos especificar cual ser\u00e1 el directorio root. La mejor forma de hacerlo es copiar y pegar la parte final de la url que nos aparece cuando estamos en el directorio que queremos que rclone tenga acceso. y Otra de las preguntas que nos aparecer\u00e1n es si deseamos editar la configuraci\u00f3n avanzada, para nuestro supuesto no es necesario, por lo que seleccionaremos \" n \". La siguiente cuesti\u00f3n a tener en cuenta es si deseamos utilizar la configuraci\u00f3n autom\u00e1tica. Como podemos ver en la explicaci\u00f3n, en el segundo punto nos indica que s\u00ed estamos trabajando en una m\u00e1quina remota (por ejemplo contra nuestro servidor v\u00eda ssh) debemos seleccionar la opci\u00f3n \" n \", que ser\u00e1 la opci\u00f3n que seleccionaremos. Al haber pulsado la opci\u00f3n \" n \" nos mostrar\u00e1 una direcci\u00f3n que debemos copiar y pegar en nuestro navegador. Esta direcci\u00f3n nos solicitar\u00e1 autenticarnos con la cuenta de Google Drive que queremos vincular con Rclone. Una vez que nos autentiquemos nos aparecer\u00e1 un c\u00f3digo que copiaremos y pegaremos en la l\u00ednea que nos solicita Rclone. Antes de finalizar, nos preguntar\u00e1 si deseamos configurar como un Team Drive [^1], no es nuestro caso por lo tanto seleccionaremos \" n \". Nos mostrar\u00e1 un peque\u00f1o resumen con el \" remote \" que hemos configurado. Para finalizar debemos seleccionar con la letra \" q \" (Quit config).","title":"Configuraci\u00f3n:"},{"location":"Herramientas/Rclone/#opciones-utilizadas","text":"Nuestro objetivo es sincronizar el directorio al que hemos dado acceso a rclone con un directorio que tenemos en nuestro NAS. Como ya hemos hablado en la primera parte, para la sincronizaci\u00f3n hemos utilizado el comando rclone sync . Para el correcto funcionamiento hemos hecho uso de varios par\u00e1metros/flags que se explicar\u00e1n a continuaci\u00f3n.","title":"Opciones utilizadas:"},{"location":"Herramientas/Rclone/#logging","text":"Utilizaremos dos opciones para monitorizar rclone. -v, --verbose : rclone tiene 4 niveles de log, ERROR , AVISO , INFO Y DEBUG . Cuando utilizamos -v , rclone muestra los tres primeros niveles de error. --log-file=FILE : en combinaci\u00f3n con la anterior, todo el log monitorizado lo enviamos a un fichero, que ser\u00e1 el que establecemos despu\u00e9s del s\u00edmbolo = .","title":"Logging"},{"location":"Herramientas/Rclone/#bwlimit","text":"--bwlimit : con est\u00e1 opci\u00f3n limitamos el ancho de banda. En nuestro caso la utilizaremos para no ocupar todo el ancho de banda que nos proporciona nuestro ISP. Por la web se puede ver limitaciones de 8650k (Hace referencia a 8650 KBytes, que si hacemos la operaci\u00f3n matem\u00e1tica correspondiente son aproximadamente 750GB diarios, que es el limite para los Team Drive enlace m\u00e1s abajo ). Seg\u00fan lo que se puede leer por algunas consultas realizadas al soporte de Google, no hay limitaciones, salvo en los que se refiere a contenido de video (Por ejemplo si queremos utilizar GD para almac\u00e9n del contenido de Plex) y de hosting. Limitaciones de Google: Files you can store in Google Drive Team Drive Limits ; After you've uploaded 750 GB to a Team Drive in 1 day, you'll be blocked from uploading additional files that day. However, file uploads already in progress will complete, up to a 5 TB maximum for a single file.","title":"Bwlimit"},{"location":"Herramientas/Rclone/#update","text":"-u, --update : con esta opci\u00f3n obligamos a rclone que omita cualquier archivo que tenga una hora de modificaci\u00f3n m\u00e1s reciente en destino que en origen. Adem\u00e1s, si el archivo tiene la misma hora de modificaci\u00f3n en destino como en origen, s\u00f3lo se actualizar\u00e1 si el tama\u00f1o es diferente.","title":"Update"},{"location":"Herramientas/Rclone/#tpslimit","text":"--tpslmit : debido a los baneos de las cuentas de google drive (los baneos son de 24 horas, que es el tiempo que tarde Google en refrescar las estad\u00edsticas , desconozco si los baneos son mayores si el baneo es reiterado). Seg\u00fan lo que he podido leer en varios grupos de telegram y por internet, la cifra m\u00e1s acertada es 8, que son el n\u00famero de peticiones m\u00e1ximas por segundo que har\u00edamos a la API de Google.","title":"Tpslimit"},{"location":"Herramientas/Rclone/#transfers","text":"--transfers : es el n\u00famero de transferencias en paralelo que se realizan. Por defecto rclone establece 4 transferencias en paralelo. Puesto que me parece un n\u00famero excesivamente bajo, y aprovechando el ancho de banda que le hemos dados, vamos a elevar el n\u00famero a 15. Estas son las opciones que hemos necesitado introducir para que la sincronizaci\u00f3n funcione correctamente. Lo que pretendemos es una sincronizaci\u00f3n y con la ejecuci\u00f3n de rclone sync en una ocasi\u00f3n no conseguiremos la sincronizaci\u00f3n indefinida, la sincronizaci\u00f3n se completa cada vez que este comando se ejecuta, por lo tanto para facilitar esto haremos uso de dos peque\u00f1os scripts. Script 1: 1 2 3 #!/bin/bash rclone sync ASIR: /sharedfolders/ASIRDrive -v --log-file = /home/Logs/rclonesync.txt -u --bwlimit 8650k --tpslimit 10 --transfers 15 exit Script 2: 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash #Comprobamos que el script no se est\u00e1 ejecutando mediante pidof if pidof -o %PPID -x sh /home/Scripts/rclonesync.sh ; then exit 1 fi #Despu\u00e9s de comprobar, si no se est\u00e1 ejecutando pasar\u00e1 a ejecutar los siguientes comandos. echo \"Ejecutando rclonesync...\" #Puesto que la ruta de los scripts no se encuentra en la variable PATH es neceario indicarle la ruta completa. Esto ejecutar\u00e1 el \"Script 1\" /home/Scripts/rclonesync.sh echo \"\u00a1La ejecuci\u00f3n del script ha finalizado!\" exit Note La ruta que establecida despu\u00e9s de sh puede diferir con la que utilic\u00e9is. Ten\u00e9is que indicar la ruta donde se encuentra vuestro script. Una vez que hemos creado los Scripts en el directorio de Rclone que hayamos decidido, les daremos permiso de ejecuci\u00f3n para que no sea necesario llamar al comando sh y con poner la ruta completa del script sea suficiente. Esto nos evitar\u00e1 algunos problemas que pueden surgir con el comando pidof. 1 chmod a + x / home / Scripts /* a+x: otorgamos permisos ejecuci\u00f3n a todos los usuarios. /home/Scripts/*: a todo el contenido que se encuentra en esta ruta. Ya tenemos los scripts que queremos ejecutar para controlar de una forma m\u00e1s sencilla la sincronizaci\u00f3n, pero nos falta configurar que el sistema ejecute estos scripts autom\u00e1ticamente. \u00bfQu\u00e9 necesitamos? Como hemos hecho en otras ocasiones, haremos uso del programador de trabajos de Linux, es decir, de cron. Rockstor est\u00e1 limitado para crear tareas planificadas desde la interfaz web, \u00fanicamente nos permite crear varias tareas ya planificadas por el sistema, y no las nuestras propias. Una vez m\u00e1s debemos hacer uso de la l\u00ednea de comandos, utilizaremos el comando crontab para a\u00f1adir la ejecuci\u00f3n del \"Script 2\" cada 30 minutos . 1 2 3 4 5 #Abrimos el editor de cron crontab -e #A\u00f1adimos la tarea */30 * * * * /home/Scripts/comprobar_rclonesync.sh","title":"Transfers"},{"location":"Herramientas/Rclone/#control-de-logs","text":"Por la web de Rclone no se menciona nada sobre el control del tama\u00f1o de los log que se van generando. Ser\u00eda interesante poder eliminar los datos antiguos, es decir establecer un l\u00edmite de por ejemplo 10MB y cuando llegue a ese l\u00edmite que vaya eliminando logs antiguos para poder introducir nuevos logs. Como digo, no he visto forma de hacerlo por lo tanto voy a a\u00f1adir a cron un comando a ejecutar para que compruebe el tama\u00f1o de los logs y en caso de que supere el tama\u00f1o que nosotros le indiquemos (en nuestro caso ser\u00e1n 10MB) que realice una acci\u00f3n. 1 find /home/Logs/ -type f -size +10M -exec rm -f {} \\; find: comando utilizado para realizar b\u00fasquedas. /home/Logs/: es la ruta en la que queremos buscar, podemos indicarle la que queramos. La ruta que he marcado es donde se encuentran los Logs de rclone. -type f: es el tipo de fichero que queremos buscar (en linux todo es un fichero), en nuestro caso ser\u00e1 un fichero de tipo file . -size +10M: buscamos fichero mayor de 10 Megabytes. Si delante del 10 indicamos un - buscar\u00e1 ficheros menores a 10 Megabytes. Se puede establecer otras unidades de medida que se encuentran explicadas en el manual de find. -exec: nos permite ejecutar una acci\u00f3n con todo aquello que ha encontrado (en funci\u00f3n de las condiciones que le hemos marcado). rm -f: rm = remove, es decir elimina lo que hemos encontrado, y como estamos seguros de que lo que ha encontrado lo queremos eliminar pasamos el par\u00e1metro -f para que no nos solicite confirmaci\u00f3n. {}: identifica a todo lo que ha encontrado el comando find. \\;: es la finalizaci\u00f3n del comando find cuando utilizamos la opci\u00f3n -excec . Man find","title":"Control de Logs"},{"location":"Herramientas/Rclone/#otros-comandos-utiles","text":"Listremotes: nos permite listar todos los remotes que hemos configurado. 1 rclone listremotes List : nos permite listar el contenido. Hay varios comandos que podemos ejecutar que nos mostrar\u00e1n diferentes resultados. 1 2 3 4 5 6 7 8 #Lista los objetos que se encuentran en REMOTO. rclone ls REMOTO: #Lista los directorios que se encuentra en REMOTO con fecha y hora de creaci\u00f3n. rclone lsd REMOTO: #Lista todo el contenido de la ruta que le indiques, tanto directorios como ficheros. rclone lsf REMOTO: #Lista todo el contenido (ficheros y directorios) incluido lo que se encuentra en todas las subcarpetas. rclone lsl REMOTO: Tree : nos muestra un lista de todo el contenido en forma de \u00e1rbol. (No lo recomiendo utilizar ya que tarda bastante en ejecutarse) . 1 rclone tree REMOTO: Help: nos permite ver diferentes comandos o flags que podemos introducir. 1 2 3 rclone --help rclone help flags rclone help backends Note Donde aparece REMOTO es necesario sustituirlo por el nombre de la unidad que hay\u00e1is configurado.","title":"Otros comandos \u00fatiles:"},{"location":"Herramientas/Rclone/#enlaces-interesantes","text":"\u00bfQu\u00e9 son las unidades de equipos (Team Drive)? Funcionamiento de logging en rclone M\u00e1s filtros de Rclone Google OAuth \u201cinvalid_grant\u201d nightmare\u200a\u2014\u200aand how to fix it Rclone commands","title":"Enlaces interesantes:"},{"location":"Herramientas/Docker/Docker/","text":"Docker # \u00bfEn qu\u00e9 consiste? # Docker es una herramienta que permite desplegar aplicaciones en contenedores , esto permite \"levantar\" dichas aplicaciones r\u00e1pidamente y de forma portable. Para entender el funcionamiento b\u00e1sico de Docker es necesario conocer dos conceptos fundamentales, Imagenes y Contenedores . Imagenes --> Defines toda la configuraci\u00f3n, es decir el software, las librer\u00edas, etc. que necesita la aplicaci\u00f3n o servicio que se requiera. Contenedores --> una instancia en ejecuci\u00f3n de una imagen, a diferencia de una m\u00e1quina virtual, un contenedor es un proceso del sistema con lo que se aprovecha del hardware que tiene el anfitri\u00f3n, evitando tener que emular ese hardware. Escalable Destruir y recrear tantas veces como quieras, de hecho es una de las formas de actualizar los contenedores. El proceso est\u00e1 aislado del propio sistema, las imagenes est\u00e1n limpias, son super ligeras, \u00fanicamente se isntala lo necesario para correr el servicio, unas son independientes a otras, si se cae no tiene porque afectar al sistema anfitri\u00f3n ni a otros contenedores salvo que dependan unos de otros. Tenemos un repositorio: Docker Hub El peso es mucho inferior al de una m\u00e1quina virtual, de hecho de una de las imagenes base desde la cual se construye otras imagenes se denomina alpine y pesa alrededor de 15MB. La configuraci\u00f3n y los datos son persistentes ya que se utilizar una configuraci\u00f3n en base al mapeo . Raspberry pi : 1 yum install docker No podemos instalar la versi\u00f3n actual de Docker (Docker CE or Docker Comunity Edition), tenemos que instalar la versi\u00f3n de Docker que se encuentra en el repositorio. https://docs.docker.com/install/ https://wiki.centos.org/SpecialInterestGroup/AltArch/armhfp https://docs.docker.com/install/linux/docker-ce/centos/ Servicios instalados en Docker: # Syncthing","title":"Docker"},{"location":"Herramientas/Docker/Docker/#docker","text":"","title":"Docker"},{"location":"Herramientas/Docker/Docker/#en-que-consiste","text":"Docker es una herramienta que permite desplegar aplicaciones en contenedores , esto permite \"levantar\" dichas aplicaciones r\u00e1pidamente y de forma portable. Para entender el funcionamiento b\u00e1sico de Docker es necesario conocer dos conceptos fundamentales, Imagenes y Contenedores . Imagenes --> Defines toda la configuraci\u00f3n, es decir el software, las librer\u00edas, etc. que necesita la aplicaci\u00f3n o servicio que se requiera. Contenedores --> una instancia en ejecuci\u00f3n de una imagen, a diferencia de una m\u00e1quina virtual, un contenedor es un proceso del sistema con lo que se aprovecha del hardware que tiene el anfitri\u00f3n, evitando tener que emular ese hardware. Escalable Destruir y recrear tantas veces como quieras, de hecho es una de las formas de actualizar los contenedores. El proceso est\u00e1 aislado del propio sistema, las imagenes est\u00e1n limpias, son super ligeras, \u00fanicamente se isntala lo necesario para correr el servicio, unas son independientes a otras, si se cae no tiene porque afectar al sistema anfitri\u00f3n ni a otros contenedores salvo que dependan unos de otros. Tenemos un repositorio: Docker Hub El peso es mucho inferior al de una m\u00e1quina virtual, de hecho de una de las imagenes base desde la cual se construye otras imagenes se denomina alpine y pesa alrededor de 15MB. La configuraci\u00f3n y los datos son persistentes ya que se utilizar una configuraci\u00f3n en base al mapeo . Raspberry pi : 1 yum install docker No podemos instalar la versi\u00f3n actual de Docker (Docker CE or Docker Comunity Edition), tenemos que instalar la versi\u00f3n de Docker que se encuentra en el repositorio. https://docs.docker.com/install/ https://wiki.centos.org/SpecialInterestGroup/AltArch/armhfp https://docs.docker.com/install/linux/docker-ce/centos/","title":"\u00bfEn qu\u00e9 consiste?"},{"location":"Herramientas/Docker/Docker/#servicios-instalados-en-docker","text":"Syncthing","title":"Servicios instalados en Docker:"},{"location":"Herramientas/Docker/Syncthing/","text":"Sincronizaci\u00f3n multidispositivo # \u00bfC\u00f3mo trabajamos? El flujo de trabajo es importante, por lo que intentamos que tengamos todo sincronizado para ser m\u00e1s productivos. A continuaci\u00f3n se describen las herramientas utilizadas. Por un lado montamos la unidad de drive donde se almacena todo el contenido en nuestro equipo con la herramienta Raidrive , herramienta gratuita para montar la unidades de almacenamiento de servicios en la nube en nuestro equipos localmente. De este modo evitamos tener el mismo contenido de manera local para que no ocupe almacenamiento y adem\u00e1s la sincronizaci\u00f3n es instant\u00e1nea por lo que lo que modifiquemos se ver\u00e1 en todos los dispositivos. Una vez que tenemos esta parte solucinada, pasamos a utilizar otra herramienta de sincronizaci\u00f3n descentralizada (es decir que no depende de ning\u00fan servidor) para mantener sincronizada toda la informaci\u00f3n. Esta herramienta utilizada se llamada Syncthing . Para la instalaci\u00f3n de esta herramienta en los diferentes dispositivos hemos utilizado Docker, donde explicamos un poco en que consiste esta herramienta en este enlace Lo utilizamos para mantener sincronizado el contenido de la web entre el NAS y la raspberry pi. A device ID is a unique, cryptographically-secure identifier that is generated as part of the key generation the first time you start Syncthing. Two devices will only connect and talk to each other if they are both configured with each other\u2019s device ID. Since the configuration must be mutual for a connection to happen, device IDs don\u2019t need to be kept secret. They are essentially part of the public key. Syncthing - Windows 10 # En otro Si ejecutamos syncthing se nos abrir\u00e1 la consola de comandos de Windows y el navegador, por ese motivo se utilizan esa serie de argumentos para que esto no se incie. La ruta por defecto es un directorio Sync dentro del usuario con el que hemos iniciado sesi\u00f3n. Descarga la versi\u00f3n de 64 bits Nos interesa que la herramienta Syncthing est\u00e9 funcionando en todo momento y que adem\u00e1s se inicie con el sistema. Para ello hemos creado un fichero .bat que ser\u00e1 introducido en la ruta que utilizado Windows para iniciar las aplicaciones con el Sistema Operativo. 1 start \"Syncthing\" syncthing . exe -no-console -no-browser Start on login Syncthing - Raspberry pi # Puesto que rclone no funciona correctamente en la raspberry optamos por utilizar Syncthing como herramienta de sincronizaci\u00f3n para tener toda la documentaci\u00f3n organizada. Por defecto el espacio que hay en la raspberry pi es muy peque\u00f1o en la partici\u00f3n home del root por lo que es necesario expandirla, los pasos a seguir son: Note: Necesario hacerlo antes de realizar cualquier otra cosa puesto que todo lo que hay en la partici\u00f3n \"root\" se pierde. Fuente: https://github.com/rharmonson/richtech/wiki/Using-CentOS-7.2.1511-Minimal-on-the-Raspberry-PI-3#manual-expand-rootfs","title":"Sincronizaci\u00f3n multidispositivo"},{"location":"Herramientas/Docker/Syncthing/#sincronizacion-multidispositivo","text":"\u00bfC\u00f3mo trabajamos? El flujo de trabajo es importante, por lo que intentamos que tengamos todo sincronizado para ser m\u00e1s productivos. A continuaci\u00f3n se describen las herramientas utilizadas. Por un lado montamos la unidad de drive donde se almacena todo el contenido en nuestro equipo con la herramienta Raidrive , herramienta gratuita para montar la unidades de almacenamiento de servicios en la nube en nuestro equipos localmente. De este modo evitamos tener el mismo contenido de manera local para que no ocupe almacenamiento y adem\u00e1s la sincronizaci\u00f3n es instant\u00e1nea por lo que lo que modifiquemos se ver\u00e1 en todos los dispositivos. Una vez que tenemos esta parte solucinada, pasamos a utilizar otra herramienta de sincronizaci\u00f3n descentralizada (es decir que no depende de ning\u00fan servidor) para mantener sincronizada toda la informaci\u00f3n. Esta herramienta utilizada se llamada Syncthing . Para la instalaci\u00f3n de esta herramienta en los diferentes dispositivos hemos utilizado Docker, donde explicamos un poco en que consiste esta herramienta en este enlace Lo utilizamos para mantener sincronizado el contenido de la web entre el NAS y la raspberry pi. A device ID is a unique, cryptographically-secure identifier that is generated as part of the key generation the first time you start Syncthing. Two devices will only connect and talk to each other if they are both configured with each other\u2019s device ID. Since the configuration must be mutual for a connection to happen, device IDs don\u2019t need to be kept secret. They are essentially part of the public key.","title":"Sincronizaci\u00f3n multidispositivo"},{"location":"Herramientas/Docker/Syncthing/#syncthing-windows-10","text":"En otro Si ejecutamos syncthing se nos abrir\u00e1 la consola de comandos de Windows y el navegador, por ese motivo se utilizan esa serie de argumentos para que esto no se incie. La ruta por defecto es un directorio Sync dentro del usuario con el que hemos iniciado sesi\u00f3n. Descarga la versi\u00f3n de 64 bits Nos interesa que la herramienta Syncthing est\u00e9 funcionando en todo momento y que adem\u00e1s se inicie con el sistema. Para ello hemos creado un fichero .bat que ser\u00e1 introducido en la ruta que utilizado Windows para iniciar las aplicaciones con el Sistema Operativo. 1 start \"Syncthing\" syncthing . exe -no-console -no-browser Start on login","title":"Syncthing - Windows 10"},{"location":"Herramientas/Docker/Syncthing/#syncthing-raspberry-pi","text":"Puesto que rclone no funciona correctamente en la raspberry optamos por utilizar Syncthing como herramienta de sincronizaci\u00f3n para tener toda la documentaci\u00f3n organizada. Por defecto el espacio que hay en la raspberry pi es muy peque\u00f1o en la partici\u00f3n home del root por lo que es necesario expandirla, los pasos a seguir son: Note: Necesario hacerlo antes de realizar cualquier otra cosa puesto que todo lo que hay en la partici\u00f3n \"root\" se pierde. Fuente: https://github.com/rharmonson/richtech/wiki/Using-CentOS-7.2.1511-Minimal-on-the-Raspberry-PI-3#manual-expand-rootfs","title":"Syncthing - Raspberry pi"},{"location":"Incidencias/30-04-2019/","text":"Recuperaci\u00f3n Contrase\u00f1a Windows Server 2012 # Para recuperar la contrase\u00f1a del Servidor de Windows ha sido necesario iniciar la m\u00e1quina con un USB booteable con Windows Server 2012. Los pasos a seguir han sido los siguientes (Obviamos la creaci\u00f3n del USB puesto que ya lo ten\u00edamos creado de las instalaciones principales): Una vez que hemos arrancado la m\u00e1quina con el USB booteable necesitamos entrar en modo recuperaci\u00f3n , seleccionamos las opciones avanzadas y en la lista que aparece debemos entrar en el S\u00edmbolo del sistema . Se abrir\u00e1 el s\u00edmbolo del sistema, donde debemos introducir una serie de comandos. Antes de la introducci\u00f3n de cualquier comando debemos situarnos en la unidad del sistema operativo, para ellos debemos ejecutar E:\\ , donde la letra \"E\" es la unidad donde se encuentra nuestro Sistema Operativo. Nos encontramos en la unidad del Sistema, por lo tanto podemos introducir los comandos necesarios. \u200b - Nos posicionamos en el directorio System32. 1 E : \\> cd Windows \\ System32 \u200b - Creamos una copia de seguridad del fichero que vamos a sustituir. 1 E : \\> move sethc . exe sethc . exe . bak \u200b - Renombramos el fichero ejecutable que representa el CMD. 1 E : \\> rename cmd . exe sethc . exe Con estos comandos que hemos ejecutado lo que hemos conseguido es renombrar el fichero que representa el ejecutable de accesibilidad, de ese modo una vez que iniciemos nuestro Servidor de forma normal, en la pantalla de inicio de sesi\u00f3n podremos abrir el s\u00edmbolo del sistema. Nos encontramos con el s\u00edmbolo del sistema abierto, en el que ya podemos ejecutar los comandos para recuperar la contrase\u00f1a. \u200b - Activar la cuenta de nuevo. 1 C : \\> net user administrador / active : yes \u200b - Cambiar la contrase\u00f1a. 1 C : \\> net user administrador p @ssw0rd Por \u00faltimo, comprobamos que iniciamos sesi\u00f3n. Una vez que hayamos iniciado sesi\u00f3n recuperamos los ficheros modificados para dejar el sistema correctamente configurado.","title":"Restaurar contrase\u00f1a WS"},{"location":"Incidencias/30-04-2019/#recuperacion-contrasena-windows-server-2012","text":"Para recuperar la contrase\u00f1a del Servidor de Windows ha sido necesario iniciar la m\u00e1quina con un USB booteable con Windows Server 2012. Los pasos a seguir han sido los siguientes (Obviamos la creaci\u00f3n del USB puesto que ya lo ten\u00edamos creado de las instalaciones principales): Una vez que hemos arrancado la m\u00e1quina con el USB booteable necesitamos entrar en modo recuperaci\u00f3n , seleccionamos las opciones avanzadas y en la lista que aparece debemos entrar en el S\u00edmbolo del sistema . Se abrir\u00e1 el s\u00edmbolo del sistema, donde debemos introducir una serie de comandos. Antes de la introducci\u00f3n de cualquier comando debemos situarnos en la unidad del sistema operativo, para ellos debemos ejecutar E:\\ , donde la letra \"E\" es la unidad donde se encuentra nuestro Sistema Operativo. Nos encontramos en la unidad del Sistema, por lo tanto podemos introducir los comandos necesarios. \u200b - Nos posicionamos en el directorio System32. 1 E : \\> cd Windows \\ System32 \u200b - Creamos una copia de seguridad del fichero que vamos a sustituir. 1 E : \\> move sethc . exe sethc . exe . bak \u200b - Renombramos el fichero ejecutable que representa el CMD. 1 E : \\> rename cmd . exe sethc . exe Con estos comandos que hemos ejecutado lo que hemos conseguido es renombrar el fichero que representa el ejecutable de accesibilidad, de ese modo una vez que iniciemos nuestro Servidor de forma normal, en la pantalla de inicio de sesi\u00f3n podremos abrir el s\u00edmbolo del sistema. Nos encontramos con el s\u00edmbolo del sistema abierto, en el que ya podemos ejecutar los comandos para recuperar la contrase\u00f1a. \u200b - Activar la cuenta de nuevo. 1 C : \\> net user administrador / active : yes \u200b - Cambiar la contrase\u00f1a. 1 C : \\> net user administrador p @ssw0rd Por \u00faltimo, comprobamos que iniciamos sesi\u00f3n. Una vez que hayamos iniciado sesi\u00f3n recuperamos los ficheros modificados para dejar el sistema correctamente configurado.","title":"Recuperaci\u00f3n Contrase\u00f1a Windows Server 2012"},{"location":"Lenguaje-de-Marcas/Markdown/","text":"Sintaxis Markdown # Negrita y cursiva # Comenzando con la sintaxis Markdown, estoy siguiendo una peque\u00f1a gu\u00eda que introduce la sintaxis m\u00e1s b\u00e1sica a utilizar. La gu\u00eda en cuesti\u00f3n se encuentra pulsando aqu\u00cd . Para escribir en negrita utilizaremos los asteriscos ** , tanto al inicio como al final de la palabra o texto que queramos que aparezca en negrita. Un ejemplo: 1 ** Markdown ** Como comentaba, tambi\u00e9n es posible establecer en negrita un fragmento de texto completo: 1 ** Esta es una frase en negrita ** Para redactar en cursiva utilizaremos el guion bajo _ , tanto al inicio como al final, al igual que sucede con la negrita. 1 2 _Markdown_ _Esta es una frase en cursiva_ Tambi\u00e9n existe la posibilidad de combinar tanto negrita como cursiva . Ejemplo: 1 _ ** Un ejemplo de combinar negrita y cursiva ** _ Los encabezados # La segunda parte de esta peque\u00f1a gu\u00eda trata sobre los encabezados. Los encabezados nos ayudan a organizar el contenido mediante secciones. En la sintaxis markdown tenemos seis niveles de encabezado, y todos ellos se identifican mediante la \"almohadilla\" # . Es decir, el numero de \"almohadillas\" vendr\u00e1 definido por el nivel de encabezado que queramos establecer. A continuaci\u00f3n veremos un ejemplo: 1 2 3 4 5 6 # Enacabezado de nivel 1 ## Encabezado de nivel 2 ### Encabezado de nivel 3 #### Encabezado de nivel 4 ##### Encabezado de nivel 5 ###### Encabezado de nivel 6 Hay que tener en cuenta, que dependiendo de la herramienta que estemos utilizando en nuestros equipos para redactar texto plano en formato markdown, los encabezados y otro tipo de sintaxis lo \"decorar\u00e1\" en funci\u00f3n al tema que estemos utilizando en dicha herramienta. En mi caso estoy utilizando actualmente la aplicaci\u00f3n Typora con el tema \"Mystic\". Pod\u00e9is encontrar m\u00e1s temas pulsando aqu\u00ed . Enlaces # En muchas ocasiones, podemos ver como en muchos blogs utilizan los enlaces para dirigirnos a otras secciones de la misma p\u00e1gina web, o incluso a webs diferentes. Esto se utiliza mucho para permitir al lector profundizar en alg\u00fan tema que se ha mencionado pero no se ha tratado al completo durante la lectura. Para poder introducir una enlace \"dentro\" de una palabra o una porci\u00f3n de texto, es necesario seguir la siguiente sintaxis: 1 Enlace a [ google ] ( https : // www . google . es ), donde google es el texto al que queremos introducir un enlace , que en este caso nos llevar\u00e1 a la p\u00e1gina principal del buscado Google . El resultado ser\u00eda el siguiente: Enlace a google . Como ya os habr\u00e9is dado cuenta, en las anteriores secciones he introducido diferentes enlaces siguiendo \u00e9sta sintaxis. Es importante tener en cuenta, que para enlaces externos debemos escribir tambi\u00e9n el protocolo utilizado ( https://, http://, ftp:///, etc. ) . Una caracter\u00edstica muy interesante y que nos ahorrar\u00e1 tiempo en funci\u00f3n de los enlaces que sean id\u00e9nticos, es la posibilidad de utilizar los \" reference link \". Esto nos permite utilizar en un documento una palabra o frase como enlace externo. A esta palabra o frase le especificamos el enlace externo (esto no se mostrar\u00e1 en nuestro documento Markdown) y de ese modo cuando queramos modificar dicho enlace externo s\u00f3lo ser\u00e1 necesario modificarlo en una ocasi\u00f3n. Lo veremos con un ejemplo para que quede lo m\u00e1s claro posible. 1 2 3 4 5 6 Este enlace nos llevar\u00e1 a [ google ][ primer enlace ] y este otro tambi\u00e9n nos llevar\u00e1 a [ google ][ primer enlace ]. te otro enlace queremos que nos lleve a [ github ][ segundo enlace ], y para terminar un tercer y \u00fa ltimo enlace que nos llevar\u00e1 a la la [ web de google ][ primer enlace ]. [ primer enlace ] : www . google . es [ segundo enlace ] : www . github . com * Esta \u00fa ltima parte es la que no se mostrar\u00e1 en Markdown , es donde identificamos los \"verdaderos enlaces\" . Este enlace nos llevar\u00e1 a google , y este otro tambi\u00e9n nos llevar\u00e1 a google . Este otro enlace queremos que nos lleve a github , y para terminar un tercer y \u00faltimo enlace que nos llevar\u00e1 a la la web de google . Adem\u00e1s de utilizar los enlaces para dirigirnos a otras webs u otras partes de nuestra propia p\u00e1gina web, podemos utilizar los links para dirigirnos a diferentes secciones de la web en la que nos encontramos en esos momentos. Para ello nos aprovecharemos de los encabezados, ya que la sintaxis ser\u00eda la siguiente: 1 2 Queremos ir la la secci\u00f3n \"Encabezados\" ; [ Link a los encabezados ]( # Los encabezados ) Queremos ir la la secci\u00f3n \"Encabezados\"; Link a los encabezados Para terminar con los enlaces, s\u00ed queremos que el enlace aparezca tal y como lo podemos ver en un navegador, \u00fanicamente es necesario utilizar los < brackets > . 1 < https : // www . google . es > Resultado: https://google.es Note Tal y como hemos ido comentando, podemos mezclar las diferentes marcas (recordemos que Markdown es un lenguaje de marcado), es decir, podr\u00edamos establecer \"google\" en negrita, cursiva, como encabezado o lo que se nos ocurriese. Insertando im\u00e1genes # El funcionamiento es muy similar al de los enlaces, salvo que necesitamos a\u00f1adir el s\u00edmbolo de exclamaci\u00f3n ! al comienzo. Veamos como es la sintaxis. 1 ! [ Grulla Origami ]( https : //images.vexels.com/media/users/3/147901/isolated/preview/96d59de576536789086c1e0b82fc91a7-grulla-de-papel-origami-by-vexels.png) El s\u00edmbolo de exclamaci\u00f3n va al comienzo tal y como hemos comentado, y los que se encuentra entre corchetes es el t\u00edtulo de la imagen, lo que se utiliza a modo de \"texto alternativo a la imagen\" para la accesibilidad o lo que muestra el navegador cuando no es capaz de cargar dicha imagen. Note Tambi\u00e9n podemos utilizar los \" reference link \" al igual que lo hac\u00edamos con los enlaces. Blockquotes # Este apartado es de los m\u00e1s sencillos de la sintaxis que utilizamos en Markdown, ya que se compone exclusivamente del s\u00edmbolo \"mayor que\" > . Hay que tener en cuenta que para nos mantenga un mismo texto en la misma cita y no nos los separe, es necesario que el espacio entre p\u00e1rrafos contenga > . Veamos un ejemplo: 1 2 3 4 5 6 7 8 > Damos comienzo al primer p\u00e1rrafo . > > > La l\u00ednea superior corresponde a la l\u00ednea de espacio entre p\u00e1rrafos . > > > > Un \u00fa ltimo p\u00e1rrafo para finalizar con el ejemplo , vamos a exagerar el espacio entre p\u00e1rrafos . Damos comienzo al primer p\u00e1rrafo. La l\u00ednea superior corresponde a la l\u00ednea de espacio entre p\u00e1rrafos. Un \u00faltimo p\u00e1rrafo para finalizar con el ejemplo. 1 2 3 4 5 6 7 8 9 > Damos comienzo al primer p\u00e1rrafo . > La l\u00ednea superior corresponde a la l\u00ednea de espacio entre p\u00e1rrafos . > Un \u00fa ltimo p\u00e1rrafo para finalizar con el ejemplo , vamos a exagerar el espacio entre p\u00e1rrafos . Damos comienzo al primer p\u00e1rrafo. La l\u00ednea superior corresponde a la l\u00ednea de espacio entre p\u00e1rrafos. Un \u00faltimo p\u00e1rrafo para finalizar con el ejemplo. Es f\u00e1cil identificar la diferencia en la \u00faltima parte, donde se exagera el espaciado. Como vemos lo introduce en una cita diferente. Creaci\u00f3n de listas # Contamos con dos tipos de listas, las ordenadas y las desordenadas. Las listas ordenadas hacen referencia a las numeradas, y la listas desordenadas hacen referencia a las listas que van precedidas con el s\u00edmbolo * . Veamos un ejemplo de ambos casos. Lista ordenada: 1 2 3 1 . Pan 2 . Huevos 3 . Leche Pan Huevos Leche Lista desordenada 1 2 3 * Pan * Huevos * Leche Pan Huevos Leche Las listas tambi\u00e9n pueden tener diferentes niveles, es decir, se pueden identar. Para ello \u00fanicamente es necesario a\u00f1adir un espacio en la lista que queremos identar sobre la anterior. Adem\u00e1s podemos mezclar las listas ordenadas con listas desordenadas. 1 2 3 4 5 6 7 8 9 1 . Pan * 1 barra normal * 2 barras chapata 2 . Huevos * 1 docena caseros * 1 / 2 docena codorniz 3 . Leche * 2 litros desnatada * 6 litros entera Tablas # Para crear tablas en Markdown es muy sencillo, de hecho utilizando editores destinados a la sintaxis Markdown, una vez introducida la primera l\u00ednea de la sintaxis nos crear\u00e1 una tabla, que ser\u00e1 muy sencilla de editar. 1 2 3 4 | Primera Columna | Segunda columna | Tercera columna | | :- ------------------- | :- ------------------: | ------------------: | | Contenido | Contenido | Contenido | | Alineaci\u00f3n izquierda | Alineaci\u00f3n centrada | Alineaci\u00f3n derecha | Como podemos ver en el contenido de la parte de arriba, para la creaci\u00f3n de las tables debemos tener varios aspectos en cuenta: El car\u00e1cter | es el utilizado para dividir las diferentes columnas de la tabla. Los : son utilizados para la alineaci\u00f3n del texto. Dos puntos a la izquierda alineaci\u00f3n izquierda , dos puntos a la derecha alineaci\u00f3n derecha y dos puntos a ambos lados alineaci\u00f3n centrada . Las l\u00edneas que vemos en la segunda fila, son las divisoras entre el encabezado y el contenido de la tabla. El resultado es el que vemos a continuaci\u00f3n: Primera Columna Segunda columna Tercera columna Contenido Contenido Contenido Alineaci\u00f3n izquierda Alineaci\u00f3n centrada Alineaci\u00f3n derecha Notas finales # Para terminar con la sintaxis Markdown, vamos a dejar unos apuntes finales sobre alguna sintaxis a tener en cuenta. Notas de pie de p\u00e1gina . La sintaxis ser\u00eda del siguiente modo: 1 2 A\u00f1adimos una nota al pie de p\u00e1gina [ ^ 1 ] [ ^ 1 ]: Aqu\u00ed est\u00e1 la nota A\u00f1adimos una nota al pie de p\u00e1gina 1 Subrayado del texto . Utilizamos la sintaxis de html : 1 <u> Subrayamos el texto </u> \u200b Subrayamos el texto L\u00ednea horizontal. Esta l\u00ednea la he utilizado durante todo el documento para dividir las diferentes secciones. La sintaxis es la siguiente: 1 --- Texto tachado . Utilizamos el s\u00edmbolo \" virgulilla \", que aparece pulsando Alt Gr + 4 . La sintaxis ser\u00eda del siguiente modo: 1 ~~ Texto tachado ~~ \u200b ~~Texto tachado~~ Utilizar las \"marcas\" sin que afecte a la sintaxis . Veamos un ejemplo: 1 \\ ** Podemos utilizar las \"marcas\" sin que afecten a la sintaxis ** \u200b * Podemos utilizar las \"marcas\" sin que afecten a la sintaxis * Inserci\u00f3n de video. Muchas webs utilizadas como plataformas de video, ofrecen la posibilidad de copiar el c\u00f3digo como <iframe> 1 <iframe width= \"560\" height= \"315\" src= \"https://www.youtube.com/embed/TtSWo2nbzAk\" frameborder= \"0\" allow= \"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen ></iframe> Enlaces de inter\u00e9s # Web del desarrollador de Markdown Typora Ampliando informaci\u00f3n de Markdown Gu\u00eda pr\u00e1ctica Markdown Joedicastro Aqu\u00ed est\u00e1 la nota \u21a9","title":"Markdown"},{"location":"Lenguaje-de-Marcas/Markdown/#sintaxis-markdown","text":"","title":"Sintaxis Markdown"},{"location":"Lenguaje-de-Marcas/Markdown/#negrita-y-cursiva","text":"Comenzando con la sintaxis Markdown, estoy siguiendo una peque\u00f1a gu\u00eda que introduce la sintaxis m\u00e1s b\u00e1sica a utilizar. La gu\u00eda en cuesti\u00f3n se encuentra pulsando aqu\u00cd . Para escribir en negrita utilizaremos los asteriscos ** , tanto al inicio como al final de la palabra o texto que queramos que aparezca en negrita. Un ejemplo: 1 ** Markdown ** Como comentaba, tambi\u00e9n es posible establecer en negrita un fragmento de texto completo: 1 ** Esta es una frase en negrita ** Para redactar en cursiva utilizaremos el guion bajo _ , tanto al inicio como al final, al igual que sucede con la negrita. 1 2 _Markdown_ _Esta es una frase en cursiva_ Tambi\u00e9n existe la posibilidad de combinar tanto negrita como cursiva . Ejemplo: 1 _ ** Un ejemplo de combinar negrita y cursiva ** _","title":"Negrita y cursiva"},{"location":"Lenguaje-de-Marcas/Markdown/#los-encabezados","text":"La segunda parte de esta peque\u00f1a gu\u00eda trata sobre los encabezados. Los encabezados nos ayudan a organizar el contenido mediante secciones. En la sintaxis markdown tenemos seis niveles de encabezado, y todos ellos se identifican mediante la \"almohadilla\" # . Es decir, el numero de \"almohadillas\" vendr\u00e1 definido por el nivel de encabezado que queramos establecer. A continuaci\u00f3n veremos un ejemplo: 1 2 3 4 5 6 # Enacabezado de nivel 1 ## Encabezado de nivel 2 ### Encabezado de nivel 3 #### Encabezado de nivel 4 ##### Encabezado de nivel 5 ###### Encabezado de nivel 6 Hay que tener en cuenta, que dependiendo de la herramienta que estemos utilizando en nuestros equipos para redactar texto plano en formato markdown, los encabezados y otro tipo de sintaxis lo \"decorar\u00e1\" en funci\u00f3n al tema que estemos utilizando en dicha herramienta. En mi caso estoy utilizando actualmente la aplicaci\u00f3n Typora con el tema \"Mystic\". Pod\u00e9is encontrar m\u00e1s temas pulsando aqu\u00ed .","title":"Los encabezados"},{"location":"Lenguaje-de-Marcas/Markdown/#enlaces","text":"En muchas ocasiones, podemos ver como en muchos blogs utilizan los enlaces para dirigirnos a otras secciones de la misma p\u00e1gina web, o incluso a webs diferentes. Esto se utiliza mucho para permitir al lector profundizar en alg\u00fan tema que se ha mencionado pero no se ha tratado al completo durante la lectura. Para poder introducir una enlace \"dentro\" de una palabra o una porci\u00f3n de texto, es necesario seguir la siguiente sintaxis: 1 Enlace a [ google ] ( https : // www . google . es ), donde google es el texto al que queremos introducir un enlace , que en este caso nos llevar\u00e1 a la p\u00e1gina principal del buscado Google . El resultado ser\u00eda el siguiente: Enlace a google . Como ya os habr\u00e9is dado cuenta, en las anteriores secciones he introducido diferentes enlaces siguiendo \u00e9sta sintaxis. Es importante tener en cuenta, que para enlaces externos debemos escribir tambi\u00e9n el protocolo utilizado ( https://, http://, ftp:///, etc. ) . Una caracter\u00edstica muy interesante y que nos ahorrar\u00e1 tiempo en funci\u00f3n de los enlaces que sean id\u00e9nticos, es la posibilidad de utilizar los \" reference link \". Esto nos permite utilizar en un documento una palabra o frase como enlace externo. A esta palabra o frase le especificamos el enlace externo (esto no se mostrar\u00e1 en nuestro documento Markdown) y de ese modo cuando queramos modificar dicho enlace externo s\u00f3lo ser\u00e1 necesario modificarlo en una ocasi\u00f3n. Lo veremos con un ejemplo para que quede lo m\u00e1s claro posible. 1 2 3 4 5 6 Este enlace nos llevar\u00e1 a [ google ][ primer enlace ] y este otro tambi\u00e9n nos llevar\u00e1 a [ google ][ primer enlace ]. te otro enlace queremos que nos lleve a [ github ][ segundo enlace ], y para terminar un tercer y \u00fa ltimo enlace que nos llevar\u00e1 a la la [ web de google ][ primer enlace ]. [ primer enlace ] : www . google . es [ segundo enlace ] : www . github . com * Esta \u00fa ltima parte es la que no se mostrar\u00e1 en Markdown , es donde identificamos los \"verdaderos enlaces\" . Este enlace nos llevar\u00e1 a google , y este otro tambi\u00e9n nos llevar\u00e1 a google . Este otro enlace queremos que nos lleve a github , y para terminar un tercer y \u00faltimo enlace que nos llevar\u00e1 a la la web de google . Adem\u00e1s de utilizar los enlaces para dirigirnos a otras webs u otras partes de nuestra propia p\u00e1gina web, podemos utilizar los links para dirigirnos a diferentes secciones de la web en la que nos encontramos en esos momentos. Para ello nos aprovecharemos de los encabezados, ya que la sintaxis ser\u00eda la siguiente: 1 2 Queremos ir la la secci\u00f3n \"Encabezados\" ; [ Link a los encabezados ]( # Los encabezados ) Queremos ir la la secci\u00f3n \"Encabezados\"; Link a los encabezados Para terminar con los enlaces, s\u00ed queremos que el enlace aparezca tal y como lo podemos ver en un navegador, \u00fanicamente es necesario utilizar los < brackets > . 1 < https : // www . google . es > Resultado: https://google.es Note Tal y como hemos ido comentando, podemos mezclar las diferentes marcas (recordemos que Markdown es un lenguaje de marcado), es decir, podr\u00edamos establecer \"google\" en negrita, cursiva, como encabezado o lo que se nos ocurriese.","title":"Enlaces"},{"location":"Lenguaje-de-Marcas/Markdown/#insertando-imagenes","text":"El funcionamiento es muy similar al de los enlaces, salvo que necesitamos a\u00f1adir el s\u00edmbolo de exclamaci\u00f3n ! al comienzo. Veamos como es la sintaxis. 1 ! [ Grulla Origami ]( https : //images.vexels.com/media/users/3/147901/isolated/preview/96d59de576536789086c1e0b82fc91a7-grulla-de-papel-origami-by-vexels.png) El s\u00edmbolo de exclamaci\u00f3n va al comienzo tal y como hemos comentado, y los que se encuentra entre corchetes es el t\u00edtulo de la imagen, lo que se utiliza a modo de \"texto alternativo a la imagen\" para la accesibilidad o lo que muestra el navegador cuando no es capaz de cargar dicha imagen. Note Tambi\u00e9n podemos utilizar los \" reference link \" al igual que lo hac\u00edamos con los enlaces.","title":"Insertando im\u00e1genes"},{"location":"Lenguaje-de-Marcas/Markdown/#blockquotes","text":"Este apartado es de los m\u00e1s sencillos de la sintaxis que utilizamos en Markdown, ya que se compone exclusivamente del s\u00edmbolo \"mayor que\" > . Hay que tener en cuenta que para nos mantenga un mismo texto en la misma cita y no nos los separe, es necesario que el espacio entre p\u00e1rrafos contenga > . Veamos un ejemplo: 1 2 3 4 5 6 7 8 > Damos comienzo al primer p\u00e1rrafo . > > > La l\u00ednea superior corresponde a la l\u00ednea de espacio entre p\u00e1rrafos . > > > > Un \u00fa ltimo p\u00e1rrafo para finalizar con el ejemplo , vamos a exagerar el espacio entre p\u00e1rrafos . Damos comienzo al primer p\u00e1rrafo. La l\u00ednea superior corresponde a la l\u00ednea de espacio entre p\u00e1rrafos. Un \u00faltimo p\u00e1rrafo para finalizar con el ejemplo. 1 2 3 4 5 6 7 8 9 > Damos comienzo al primer p\u00e1rrafo . > La l\u00ednea superior corresponde a la l\u00ednea de espacio entre p\u00e1rrafos . > Un \u00fa ltimo p\u00e1rrafo para finalizar con el ejemplo , vamos a exagerar el espacio entre p\u00e1rrafos . Damos comienzo al primer p\u00e1rrafo. La l\u00ednea superior corresponde a la l\u00ednea de espacio entre p\u00e1rrafos. Un \u00faltimo p\u00e1rrafo para finalizar con el ejemplo. Es f\u00e1cil identificar la diferencia en la \u00faltima parte, donde se exagera el espaciado. Como vemos lo introduce en una cita diferente.","title":"Blockquotes"},{"location":"Lenguaje-de-Marcas/Markdown/#creacion-de-listas","text":"Contamos con dos tipos de listas, las ordenadas y las desordenadas. Las listas ordenadas hacen referencia a las numeradas, y la listas desordenadas hacen referencia a las listas que van precedidas con el s\u00edmbolo * . Veamos un ejemplo de ambos casos. Lista ordenada: 1 2 3 1 . Pan 2 . Huevos 3 . Leche Pan Huevos Leche Lista desordenada 1 2 3 * Pan * Huevos * Leche Pan Huevos Leche Las listas tambi\u00e9n pueden tener diferentes niveles, es decir, se pueden identar. Para ello \u00fanicamente es necesario a\u00f1adir un espacio en la lista que queremos identar sobre la anterior. Adem\u00e1s podemos mezclar las listas ordenadas con listas desordenadas. 1 2 3 4 5 6 7 8 9 1 . Pan * 1 barra normal * 2 barras chapata 2 . Huevos * 1 docena caseros * 1 / 2 docena codorniz 3 . Leche * 2 litros desnatada * 6 litros entera","title":"Creaci\u00f3n de listas"},{"location":"Lenguaje-de-Marcas/Markdown/#tablas","text":"Para crear tablas en Markdown es muy sencillo, de hecho utilizando editores destinados a la sintaxis Markdown, una vez introducida la primera l\u00ednea de la sintaxis nos crear\u00e1 una tabla, que ser\u00e1 muy sencilla de editar. 1 2 3 4 | Primera Columna | Segunda columna | Tercera columna | | :- ------------------- | :- ------------------: | ------------------: | | Contenido | Contenido | Contenido | | Alineaci\u00f3n izquierda | Alineaci\u00f3n centrada | Alineaci\u00f3n derecha | Como podemos ver en el contenido de la parte de arriba, para la creaci\u00f3n de las tables debemos tener varios aspectos en cuenta: El car\u00e1cter | es el utilizado para dividir las diferentes columnas de la tabla. Los : son utilizados para la alineaci\u00f3n del texto. Dos puntos a la izquierda alineaci\u00f3n izquierda , dos puntos a la derecha alineaci\u00f3n derecha y dos puntos a ambos lados alineaci\u00f3n centrada . Las l\u00edneas que vemos en la segunda fila, son las divisoras entre el encabezado y el contenido de la tabla. El resultado es el que vemos a continuaci\u00f3n: Primera Columna Segunda columna Tercera columna Contenido Contenido Contenido Alineaci\u00f3n izquierda Alineaci\u00f3n centrada Alineaci\u00f3n derecha","title":"Tablas"},{"location":"Lenguaje-de-Marcas/Markdown/#notas-finales","text":"Para terminar con la sintaxis Markdown, vamos a dejar unos apuntes finales sobre alguna sintaxis a tener en cuenta. Notas de pie de p\u00e1gina . La sintaxis ser\u00eda del siguiente modo: 1 2 A\u00f1adimos una nota al pie de p\u00e1gina [ ^ 1 ] [ ^ 1 ]: Aqu\u00ed est\u00e1 la nota A\u00f1adimos una nota al pie de p\u00e1gina 1 Subrayado del texto . Utilizamos la sintaxis de html : 1 <u> Subrayamos el texto </u> \u200b Subrayamos el texto L\u00ednea horizontal. Esta l\u00ednea la he utilizado durante todo el documento para dividir las diferentes secciones. La sintaxis es la siguiente: 1 --- Texto tachado . Utilizamos el s\u00edmbolo \" virgulilla \", que aparece pulsando Alt Gr + 4 . La sintaxis ser\u00eda del siguiente modo: 1 ~~ Texto tachado ~~ \u200b ~~Texto tachado~~ Utilizar las \"marcas\" sin que afecte a la sintaxis . Veamos un ejemplo: 1 \\ ** Podemos utilizar las \"marcas\" sin que afecten a la sintaxis ** \u200b * Podemos utilizar las \"marcas\" sin que afecten a la sintaxis * Inserci\u00f3n de video. Muchas webs utilizadas como plataformas de video, ofrecen la posibilidad de copiar el c\u00f3digo como <iframe> 1 <iframe width= \"560\" height= \"315\" src= \"https://www.youtube.com/embed/TtSWo2nbzAk\" frameborder= \"0\" allow= \"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen ></iframe>","title":"Notas finales"},{"location":"Lenguaje-de-Marcas/Markdown/#enlaces-de-interes","text":"Web del desarrollador de Markdown Typora Ampliando informaci\u00f3n de Markdown Gu\u00eda pr\u00e1ctica Markdown Joedicastro Aqu\u00ed est\u00e1 la nota \u21a9","title":"Enlaces de inter\u00e9s"},{"location":"Lenguaje-de-Marcas/MkDocs/","text":"MkDocs # \u00bfQu\u00e9 es MkDocs? # Tal y como podemos leer en su web , es un generador de sitios est\u00e1ticos orientado a la representaci\u00f3n de documentaci\u00f3n escrita en formato Markdown . Destaca por ser r\u00e1pido y simple, ya que la mayor parte de su configuraci\u00f3n reside en un \u00fanico fichero YAML. Instalaci\u00f3n # Partimos de la base de que tenemos adecuadamente configurada nuestra Raspberry Pi para comenzar a trabajar. Vamos a seguir los pasos de instalaci\u00f3n que podemos encontrar en su web , aunque posteriormente haremos alguna modificaci\u00f3n para adaptarlo a nuestras necesidades. Comprobamos si el paquete MkDocs se encuentra en los repositorios, para ello ejecutamos el comando yum list MkDocs . Como podemos ver, no se encuentra disponible en los respositorios que tenemos instalados actualmente, por lo tanto realizaremos su instalaci\u00f3n manualmente. Proceso de instalaci\u00f3n # Comprobamos si los paquete python y pip se encuentran instalado en nuestro sistema, para ello ejecutaremos los comandos yum list installed python y yum list installed pip . El primero de ellos se encuentra instalado y en una versi\u00f3n compatible con nuestro sistema (las versiones compatibles son 2.7, 3.4, 3.5, 3.6, 3.7). Pip no se encuentra instalado, por lo que vamos a su web para saber como instalarlo. Debemos ejecutar lo siguiente: 1 2 3 4 5 #Descargamos el fichero \"get-pip.py\" de la web que pasamos a curl curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py #Ejecutamos con el int\u00e9rprete python \"get-pip.py\" python get-pip.py Ya tenemos los requisitos necesarios para instalar MkDocs , por lo tanto procedemos a su instalaci\u00f3n. 1 pip install mkdocs Comprobamos la versi\u00f3n instalada. 1 mkdocs --version Para terminar generaremos los manpages correspondientes a MkDocs. 1 2 3 4 5 6 7 8 #Instalamos \"click-man\" pip install click-man #Generamos el manpage de mkdocs click-man --target /usr/share/man/man1 mkdocs #Actualizamos la base de datos de manpages mandb Generando un nuevo proyecto # En primer lugar, debemos crear un nuevo proyecto, donde se almacenar\u00e1n todos los documentos que se incluir\u00e1n dentro de la web est\u00e1tica que generaremos con MkDocs. 1 2 #Generando el proyecto Tipstabet mkdocs new Tipstabet En este momento, dentro del directorio Tipstabet nos encontramos con un directorio llamado docs que contendr\u00e1 toda la documentaci\u00f3n que se mostrar\u00e1 desde el navegador, y un fichero llamado mkdocs.yml , que es el fichero de configuraci\u00f3n, en el cual realizaremos algunas modificaciones. Si queremos realizar pruebas, disponemos del comando mkdocs serve , nos permite previsualizar desde el navegador donde se encuentra instalado MkDocs e introduciendo la direcci\u00f3n 127.0.0.1:8000 la web est\u00e1tica con nuestra documentaci\u00f3n. En nuestra Raspberry Pi no disponemos de entorno gr\u00e1fico, por lo que por el momento no podremos previsualizar los cambios que vayamos realizando. Configurando MkDocs # Docs # Antes de poder generar nuestro sitio web est\u00e1tico con toda la documentaci\u00f3n ser\u00e1 necesario que esa documentaci\u00f3n se encuentre en /root/Tipstabet/docs . Para que todo el contenido se mantenga sincronizado con las modificaciones que se realizan se han utilizado varias herramientas. Typora : todo el contenido se ha generado con la sintaxis markdown . Hay multitud de editores multiplataforma, pero hemos elegido este por ser gratuito, minimalista y porque se encuentra disponible en las principales plataformas orientadas a pc. Google Drive : desde nuestro centro de estudios nos han facilitado una cuenta educativa de google que nos da acceso a la suite de google. Esto nos permite tener almacenamiento ilimtado en Google Drive. Es una forma de tener disponible todo el contenido en todo momento. Rclone : herramienta utilizada para sincronizar la documentaci\u00f3n que tenemos en Google Drive con nuestro NAS . El NAS ser\u00e1 el dispositivo que compartir\u00e1 toda la documentaci\u00f3n con la Raspberry Pi para despu\u00e9s poder generar el contenido. Syncthing : se trata de una herramienta de sincronizaci\u00f3n descentralizada, similar a las redes p2p, que nos permitir\u00e1 tener en un equipo Windows de los utilizados por el proyecto, toda la documentaci\u00f3n sincronizada. Mkdocs.yml # Es una de las partes fundamentales para configurar nuestra web est\u00e1tica a nuestro gusto o necesidades. Cuando ejecutamos el comando mkdocs build , pasa el fichero mkdocs.yml para establecer los par\u00e1metros indicados. El fichero que hemos generado se encuentra en este enlace , no obstante a continuaci\u00f3n se muestra una copia exacta del mismo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #Informaci\u00f3n sobre el proyecto site_name : TipsTaBet site_author : ASIR 1 #Copyright copyright : \"Copyright &copy; 2019 ASIR 1\" #Informaci\u00f3n sobre el repositorio repo_name : 'tzinm/Tipstabet' repo_url : 'https://github.com/tzinm/Tipstabet' #Tema utilizado, con configuraciones espec\u00edficas, por ejemplo los lenguajes que interpretar\u00e1 para mostrar adecuadamente en las \"cajas\" de c\u00f3digo. theme : name : 'material' language : 'es' palette : primary : 'indigo' accent : 'indigo' feature : tabs : true favicon : ./Imagenes/favicon.ico logo : icon : 'devices_other' highlightjs : true hljs_languages : - bash - powershell - markdown - yaml #Contenido extra extra : social : - type : 'github' link : 'https://github.com/tzinm' - type : 'twitter' link : 'https://twitter.com/tzinm1' #Extensiones que a\u00f1aden funciones extra, como por ejemplo links permanentes a los encabezados de diferentes niveles. markdown_extensions : - codehilite : linenums : true - toc : permalink : true permalink : \"#\" - admonition - footnotes #\u00cdndice del contenido, nos permite organizarlo como deseemos pages : - Home : 'index.md' - Hardware : - Fichas t\u00e9cnicas : ./Hardware/Fichas-tecnicas.md - Rockstor : ./Hardware/Rockstor.md - Raspberry Pi : ./Hardware/Raspberry-Pi.md - Presupuesto Servidor : ./Hardware/Servidor.md - Control de acceso : ./Hardware/Log.md - Proyecto Celulosa : ./Hardware/Proyecto-Celulosa.md - Sistemas Operativos : - Comandos de Administraci\u00f3n : ./Sistemas-Operativos/Comandos-de-Administracion.md - Punto de restauraci\u00f3n : ./Sistemas-Operativos/Equipos-Clientes/Punto-de-Restauracion.md - Imagen del Sistema : ./Sistemas-Operativos/Equipos-Clientes/Imagenes-del-Sistema.md - Acceso Remoto : ./Sistemas-Operativos/Equipos-Clientes/Acceso-Remoto.md - Unir Linux a Windows Server : ./Sistemas-Operativos/Equipos-Clientes/Dominio-linux.md - Administraci\u00f3n de redes : - Planificaci\u00f3n de la red : ./Planificacion-Administracion-de-Redes/Red.md - Lenguaje de Marcas : - Servidor Web : ./Lenguaje-de-Marcas/Tipstabet.md - MkDocs : ./Lenguaje-de-Marcas/MkDocs.md - Markdown : ./Lenguaje-de-Marcas/Markdown.md - Contenido extra : - Easy2boot : ./Herramientas/Easy2boot.md - Rclone : ./Herramientas/Rclone.md - Incidencias : - Restaurar contrase\u00f1a WS : ./Incidencias/30-04-2019.md Note Es importante respetar la sintaxix \"yaml\" para que la generaci\u00f3n de la web con toda la documentaci\u00f3n se realice correctamente. Durante el proyecto de clase se ha utilizado el tema Read the Docs que est\u00e1 incluido dentro de la herramienta MkDocs. Para la publicaci\u00f3n de toda la documentaci\u00f3n se ha utilizado la plataforma GitHub y el tema Material for MkDocs . En el apartado Deployment with GitHub se encuentra explicado de forma m\u00e1s detallada este proceso. Nginx como servidor web # MkDocs nos brinda diferentes posibilidades para servir el contenido generado por mkdocs , hemos optados por utilizar la propia Raspberry Pi como servidor web, el cual utilizaremos para que todo el contenido generado sea accesible. El servidor web que utilizaremos para este proyecto ser\u00e1 Nginx , debido a las ventajas que proporciona sobre Apache, sobre todo en dispositivos de bajo rendimiento. Para poder instalar Nginx es necesario a\u00f1adir los repositorios epel-release (Extra Packages for Enterprise Linux). En este enlace podemos ver como a\u00f1adir estos repositorios en la versi\u00f3n de CentOS para Raspberry Pi. 1 2 3 4 5 6 7 8 cat > /etc/yum.repos.d/epel.repo << EOF [epel] name=Epel rebuild for armhfp baseurl=https://armv7.dev.centos.org/repodir/epel-pass-1/ enabled=1 gpgcheck=0 EOF Actualizamos ejecutando yum update y dispondremos del paquete Nginx para su descarga. Instalamos Nginx: 1 yum install Nginx Iniciamos Nginx: 1 systemctl start nginx Habilitamos Nginx para que se inicie con el sistema operativo: 1 systemctl enable nginx Recordamos que ya hemos habilitado el firewall para que el servidor web pueda recibir peticiones. Si revisamos el fichero de configuraci\u00f3n del servidor Nginx podemos observar que el directorio root es /usr/share/nginx/html , por lo tanto, todo lo que queramos que sea accesible desde un navegador debe incorporarse a este directorio. En el caso que queramos servir varias p\u00e1ginas web existen diferentes opciones, en este caso hemos configurado directorios virtuales en el servidor web. El contenido que generamos con el comando mkdocs build se almacena en el directorio site dentro del directorio que hemos creado para nuestro proyecto, es decir /root/Tipstabet/site . Es muy probable que deseemos realizar modificaciones, ya sea porque hemos a\u00f1adido contenido nuevo, o porque hemos modificado el contenido existente. Para ello hemos creado un peque\u00f1o script que nos realizar\u00e1 todo el proceso. 1 2 3 4 5 6 7 8 9 #!/bin/bash #Nos posicionamos en el directorio del proyecto cd /root/Tipstabet #Generamos el \"site\" con el comando mkdocs mkdocs build #Copiamos el contenido generado a la ruta correspondiente yes | cp -rf /root/Tipstabet/site/* /usr/share/nginx/html/documentacion Man cp Man yes","title":"MkDocs"},{"location":"Lenguaje-de-Marcas/MkDocs/#mkdocs","text":"","title":"MkDocs"},{"location":"Lenguaje-de-Marcas/MkDocs/#que-es-mkdocs","text":"Tal y como podemos leer en su web , es un generador de sitios est\u00e1ticos orientado a la representaci\u00f3n de documentaci\u00f3n escrita en formato Markdown . Destaca por ser r\u00e1pido y simple, ya que la mayor parte de su configuraci\u00f3n reside en un \u00fanico fichero YAML.","title":"\u00bfQu\u00e9 es MkDocs?"},{"location":"Lenguaje-de-Marcas/MkDocs/#instalacion","text":"Partimos de la base de que tenemos adecuadamente configurada nuestra Raspberry Pi para comenzar a trabajar. Vamos a seguir los pasos de instalaci\u00f3n que podemos encontrar en su web , aunque posteriormente haremos alguna modificaci\u00f3n para adaptarlo a nuestras necesidades. Comprobamos si el paquete MkDocs se encuentra en los repositorios, para ello ejecutamos el comando yum list MkDocs . Como podemos ver, no se encuentra disponible en los respositorios que tenemos instalados actualmente, por lo tanto realizaremos su instalaci\u00f3n manualmente.","title":"Instalaci\u00f3n"},{"location":"Lenguaje-de-Marcas/MkDocs/#proceso-de-instalacion","text":"Comprobamos si los paquete python y pip se encuentran instalado en nuestro sistema, para ello ejecutaremos los comandos yum list installed python y yum list installed pip . El primero de ellos se encuentra instalado y en una versi\u00f3n compatible con nuestro sistema (las versiones compatibles son 2.7, 3.4, 3.5, 3.6, 3.7). Pip no se encuentra instalado, por lo que vamos a su web para saber como instalarlo. Debemos ejecutar lo siguiente: 1 2 3 4 5 #Descargamos el fichero \"get-pip.py\" de la web que pasamos a curl curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py #Ejecutamos con el int\u00e9rprete python \"get-pip.py\" python get-pip.py Ya tenemos los requisitos necesarios para instalar MkDocs , por lo tanto procedemos a su instalaci\u00f3n. 1 pip install mkdocs Comprobamos la versi\u00f3n instalada. 1 mkdocs --version Para terminar generaremos los manpages correspondientes a MkDocs. 1 2 3 4 5 6 7 8 #Instalamos \"click-man\" pip install click-man #Generamos el manpage de mkdocs click-man --target /usr/share/man/man1 mkdocs #Actualizamos la base de datos de manpages mandb","title":"Proceso de instalaci\u00f3n"},{"location":"Lenguaje-de-Marcas/MkDocs/#generando-un-nuevo-proyecto","text":"En primer lugar, debemos crear un nuevo proyecto, donde se almacenar\u00e1n todos los documentos que se incluir\u00e1n dentro de la web est\u00e1tica que generaremos con MkDocs. 1 2 #Generando el proyecto Tipstabet mkdocs new Tipstabet En este momento, dentro del directorio Tipstabet nos encontramos con un directorio llamado docs que contendr\u00e1 toda la documentaci\u00f3n que se mostrar\u00e1 desde el navegador, y un fichero llamado mkdocs.yml , que es el fichero de configuraci\u00f3n, en el cual realizaremos algunas modificaciones. Si queremos realizar pruebas, disponemos del comando mkdocs serve , nos permite previsualizar desde el navegador donde se encuentra instalado MkDocs e introduciendo la direcci\u00f3n 127.0.0.1:8000 la web est\u00e1tica con nuestra documentaci\u00f3n. En nuestra Raspberry Pi no disponemos de entorno gr\u00e1fico, por lo que por el momento no podremos previsualizar los cambios que vayamos realizando.","title":"Generando un nuevo proyecto"},{"location":"Lenguaje-de-Marcas/MkDocs/#configurando-mkdocs","text":"","title":"Configurando MkDocs"},{"location":"Lenguaje-de-Marcas/MkDocs/#docs","text":"Antes de poder generar nuestro sitio web est\u00e1tico con toda la documentaci\u00f3n ser\u00e1 necesario que esa documentaci\u00f3n se encuentre en /root/Tipstabet/docs . Para que todo el contenido se mantenga sincronizado con las modificaciones que se realizan se han utilizado varias herramientas. Typora : todo el contenido se ha generado con la sintaxis markdown . Hay multitud de editores multiplataforma, pero hemos elegido este por ser gratuito, minimalista y porque se encuentra disponible en las principales plataformas orientadas a pc. Google Drive : desde nuestro centro de estudios nos han facilitado una cuenta educativa de google que nos da acceso a la suite de google. Esto nos permite tener almacenamiento ilimtado en Google Drive. Es una forma de tener disponible todo el contenido en todo momento. Rclone : herramienta utilizada para sincronizar la documentaci\u00f3n que tenemos en Google Drive con nuestro NAS . El NAS ser\u00e1 el dispositivo que compartir\u00e1 toda la documentaci\u00f3n con la Raspberry Pi para despu\u00e9s poder generar el contenido. Syncthing : se trata de una herramienta de sincronizaci\u00f3n descentralizada, similar a las redes p2p, que nos permitir\u00e1 tener en un equipo Windows de los utilizados por el proyecto, toda la documentaci\u00f3n sincronizada.","title":"Docs"},{"location":"Lenguaje-de-Marcas/MkDocs/#mkdocsyml","text":"Es una de las partes fundamentales para configurar nuestra web est\u00e1tica a nuestro gusto o necesidades. Cuando ejecutamos el comando mkdocs build , pasa el fichero mkdocs.yml para establecer los par\u00e1metros indicados. El fichero que hemos generado se encuentra en este enlace , no obstante a continuaci\u00f3n se muestra una copia exacta del mismo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #Informaci\u00f3n sobre el proyecto site_name : TipsTaBet site_author : ASIR 1 #Copyright copyright : \"Copyright &copy; 2019 ASIR 1\" #Informaci\u00f3n sobre el repositorio repo_name : 'tzinm/Tipstabet' repo_url : 'https://github.com/tzinm/Tipstabet' #Tema utilizado, con configuraciones espec\u00edficas, por ejemplo los lenguajes que interpretar\u00e1 para mostrar adecuadamente en las \"cajas\" de c\u00f3digo. theme : name : 'material' language : 'es' palette : primary : 'indigo' accent : 'indigo' feature : tabs : true favicon : ./Imagenes/favicon.ico logo : icon : 'devices_other' highlightjs : true hljs_languages : - bash - powershell - markdown - yaml #Contenido extra extra : social : - type : 'github' link : 'https://github.com/tzinm' - type : 'twitter' link : 'https://twitter.com/tzinm1' #Extensiones que a\u00f1aden funciones extra, como por ejemplo links permanentes a los encabezados de diferentes niveles. markdown_extensions : - codehilite : linenums : true - toc : permalink : true permalink : \"#\" - admonition - footnotes #\u00cdndice del contenido, nos permite organizarlo como deseemos pages : - Home : 'index.md' - Hardware : - Fichas t\u00e9cnicas : ./Hardware/Fichas-tecnicas.md - Rockstor : ./Hardware/Rockstor.md - Raspberry Pi : ./Hardware/Raspberry-Pi.md - Presupuesto Servidor : ./Hardware/Servidor.md - Control de acceso : ./Hardware/Log.md - Proyecto Celulosa : ./Hardware/Proyecto-Celulosa.md - Sistemas Operativos : - Comandos de Administraci\u00f3n : ./Sistemas-Operativos/Comandos-de-Administracion.md - Punto de restauraci\u00f3n : ./Sistemas-Operativos/Equipos-Clientes/Punto-de-Restauracion.md - Imagen del Sistema : ./Sistemas-Operativos/Equipos-Clientes/Imagenes-del-Sistema.md - Acceso Remoto : ./Sistemas-Operativos/Equipos-Clientes/Acceso-Remoto.md - Unir Linux a Windows Server : ./Sistemas-Operativos/Equipos-Clientes/Dominio-linux.md - Administraci\u00f3n de redes : - Planificaci\u00f3n de la red : ./Planificacion-Administracion-de-Redes/Red.md - Lenguaje de Marcas : - Servidor Web : ./Lenguaje-de-Marcas/Tipstabet.md - MkDocs : ./Lenguaje-de-Marcas/MkDocs.md - Markdown : ./Lenguaje-de-Marcas/Markdown.md - Contenido extra : - Easy2boot : ./Herramientas/Easy2boot.md - Rclone : ./Herramientas/Rclone.md - Incidencias : - Restaurar contrase\u00f1a WS : ./Incidencias/30-04-2019.md Note Es importante respetar la sintaxix \"yaml\" para que la generaci\u00f3n de la web con toda la documentaci\u00f3n se realice correctamente. Durante el proyecto de clase se ha utilizado el tema Read the Docs que est\u00e1 incluido dentro de la herramienta MkDocs. Para la publicaci\u00f3n de toda la documentaci\u00f3n se ha utilizado la plataforma GitHub y el tema Material for MkDocs . En el apartado Deployment with GitHub se encuentra explicado de forma m\u00e1s detallada este proceso.","title":"Mkdocs.yml"},{"location":"Lenguaje-de-Marcas/MkDocs/#nginx-como-servidor-web","text":"MkDocs nos brinda diferentes posibilidades para servir el contenido generado por mkdocs , hemos optados por utilizar la propia Raspberry Pi como servidor web, el cual utilizaremos para que todo el contenido generado sea accesible. El servidor web que utilizaremos para este proyecto ser\u00e1 Nginx , debido a las ventajas que proporciona sobre Apache, sobre todo en dispositivos de bajo rendimiento. Para poder instalar Nginx es necesario a\u00f1adir los repositorios epel-release (Extra Packages for Enterprise Linux). En este enlace podemos ver como a\u00f1adir estos repositorios en la versi\u00f3n de CentOS para Raspberry Pi. 1 2 3 4 5 6 7 8 cat > /etc/yum.repos.d/epel.repo << EOF [epel] name=Epel rebuild for armhfp baseurl=https://armv7.dev.centos.org/repodir/epel-pass-1/ enabled=1 gpgcheck=0 EOF Actualizamos ejecutando yum update y dispondremos del paquete Nginx para su descarga. Instalamos Nginx: 1 yum install Nginx Iniciamos Nginx: 1 systemctl start nginx Habilitamos Nginx para que se inicie con el sistema operativo: 1 systemctl enable nginx Recordamos que ya hemos habilitado el firewall para que el servidor web pueda recibir peticiones. Si revisamos el fichero de configuraci\u00f3n del servidor Nginx podemos observar que el directorio root es /usr/share/nginx/html , por lo tanto, todo lo que queramos que sea accesible desde un navegador debe incorporarse a este directorio. En el caso que queramos servir varias p\u00e1ginas web existen diferentes opciones, en este caso hemos configurado directorios virtuales en el servidor web. El contenido que generamos con el comando mkdocs build se almacena en el directorio site dentro del directorio que hemos creado para nuestro proyecto, es decir /root/Tipstabet/site . Es muy probable que deseemos realizar modificaciones, ya sea porque hemos a\u00f1adido contenido nuevo, o porque hemos modificado el contenido existente. Para ello hemos creado un peque\u00f1o script que nos realizar\u00e1 todo el proceso. 1 2 3 4 5 6 7 8 9 #!/bin/bash #Nos posicionamos en el directorio del proyecto cd /root/Tipstabet #Generamos el \"site\" con el comando mkdocs mkdocs build #Copiamos el contenido generado a la ruta correspondiente yes | cp -rf /root/Tipstabet/site/* /usr/share/nginx/html/documentacion Man cp Man yes","title":"Nginx como servidor web"},{"location":"Lenguaje-de-Marcas/Tipstabet/","text":"Nginx # La presentaci\u00f3n de este proyecto se realizar\u00e1 en formato web. Para ello es necesario contar con una parte de software, el servidor web Nginx y otra parte de hardware, una Raspberry Pi 3b . Dentro del servidor web tendremos tres partes diferenciadas, ser\u00e1 importante tenerlo en cuenta para configurar adecuadamente el servidor web. Web principal Documentaci\u00f3n Recursos Web Principal # La web principal corresponde a la web corporativa, donde se muestra la informaci\u00f3n referente a la empresa y de las personas que la conforman. Para mostrar todo el contenido se han generado ficheros del tipo html y css . Los ficheros generados se encuentran en el directorio ra\u00edz del servidor web, es decir en /usr/share/nginx/html . Esto implica que cuando accedamos a la direcci\u00f3n ip de la Raspberry desde un navegador, visualizaremos la p\u00e1gina web. Documentaci\u00f3n # En esta parte del proyecto se han documentado las diferentes tareas realizadas. Se ha utilizado la herramienta MkDocs para generar una web est\u00e1tica donde se muestra toda la documentaci\u00f3n correctamente organizada. El proceso para generar dicha web est\u00e1tica se encuentra totalmente explicado en el siguiente enlace . Al igual que en el apartado anterior, con la herramienta MkDcos se han generado ficheros del tipo html y css . Para poder visualizar este contenido como si de una web independiente a la anterior se tratase es necesario crear un directorio dentro del directorio ra\u00edz del servidor web. Debemos a\u00f1adir el siguiente bloque al fichero de configuraci\u00f3n de Nginx . 1 2 3 location / documentacion / { alias / usr / share / nginx / html / documentacion ; } El directorio creado lo hemos denominado documentacion , que se encuentra \"debajo\" del directorio ra\u00edz. Para acceder a esta p\u00e1gina web es necesario introducir en cualquier navegador la direcci\u00f3n ip de la Raspberry y a\u00f1adirle al final /documentacion/ . Con la directiva alias indicamos la ruta absoluta al directorio virtual que hemos creado, de ese modo no ser\u00e1 necesario escribir una direcci\u00f3n \"compleja\" en el navegador. Recursos # En esta parte del servidor web, indexaremos el contenido que se encuentra en /usr/share/nginx/html/documentacion/Recursos para visualizarlo en el navegador como si de un explorador de archivos se tratase. Se ha a\u00f1adido al fichero de configuraci\u00f3n de Nginx el siguiente bloque: 1 2 3 4 5 6 7 8 location / Recursos / { alias / usr / share / nginx / html / documentacion / Recursos / ; add_before_body / betterlisting / top . html ; add_after_body / betterlisting / bot . html ; autoindex on ; autoindex_localtime on ; autoindex_exact_size off ; } Para que el navegador muestre el contenido de un directorio, \u00fanicamente es necesario establecer la directiva autoindex . Por defecto, la forma en la que se muestra el contenido no es visualmente atractiva, por lo que para darle un aspecto m\u00e1s agradable hemos utilizado el proyecto betterlisting que podemos encontrar en gitlab . Hay varias directivas que no se hab\u00eda visto hasta el momento que explicaremos a continuaci\u00f3n: autoindex_exact_size off: por defecto esta directiva se encuentra activa. Si la desactivamos nos muestra el tama\u00f1o de los ficheros redondeado en KB, MB o GB. add_before_body: nos permite a\u00f1adir contenido antes de cargar el body 1 de la solicitud (el contenido a indexar). add_after_body : a diferencia de la directiva anterior a\u00f1ade contenido despu\u00e9s de cargar el body 1 . Con la dos directivas anteriores conseguimos cambiar el aspecto en el navegador cuando visualizamos el contenido indexado. En estas directivas indicamos la ruta donde se encuentra el contenido a\u00f1adido de betterlisting . Soporta diferentes tipos de ficheros, que podemos encontrar aqu\u00ed . Si queremos a\u00f1adir soporte a nuevos tipos de ficheros, simplemente modificamos el fichero top.html , y a\u00f1adimos el icono con el mismo nombre que el tipo de fichero al directorio icons . Note Si tuvi\u00e9semos ficheros de diferente \u00edndole, y queremos seleccionar cuales son los que el servidor Nginx debe indexar, podr\u00edamos hacer uso del modulo Fancy Index , que nos permite con expresiones regulares seleccionar el contenido a indexar 2 . Para terminar, en la siguiente imagen podemos ver como se encuentra organizado el directorio /usr/share/nginx/html . Fuentes # Creating Virtual Directory Apache Nginx Beginners Guide Nginxconfig.io Apaxy theme El body de la solicitud representa el contenido a indexar. \u21a9 \u21a9 Este modulo no se encuentra disponible para la arquitectura ARM. \u21a9","title":"Servidor Web"},{"location":"Lenguaje-de-Marcas/Tipstabet/#nginx","text":"La presentaci\u00f3n de este proyecto se realizar\u00e1 en formato web. Para ello es necesario contar con una parte de software, el servidor web Nginx y otra parte de hardware, una Raspberry Pi 3b . Dentro del servidor web tendremos tres partes diferenciadas, ser\u00e1 importante tenerlo en cuenta para configurar adecuadamente el servidor web. Web principal Documentaci\u00f3n Recursos","title":"Nginx"},{"location":"Lenguaje-de-Marcas/Tipstabet/#web-principal","text":"La web principal corresponde a la web corporativa, donde se muestra la informaci\u00f3n referente a la empresa y de las personas que la conforman. Para mostrar todo el contenido se han generado ficheros del tipo html y css . Los ficheros generados se encuentran en el directorio ra\u00edz del servidor web, es decir en /usr/share/nginx/html . Esto implica que cuando accedamos a la direcci\u00f3n ip de la Raspberry desde un navegador, visualizaremos la p\u00e1gina web.","title":"Web Principal"},{"location":"Lenguaje-de-Marcas/Tipstabet/#documentacion","text":"En esta parte del proyecto se han documentado las diferentes tareas realizadas. Se ha utilizado la herramienta MkDocs para generar una web est\u00e1tica donde se muestra toda la documentaci\u00f3n correctamente organizada. El proceso para generar dicha web est\u00e1tica se encuentra totalmente explicado en el siguiente enlace . Al igual que en el apartado anterior, con la herramienta MkDcos se han generado ficheros del tipo html y css . Para poder visualizar este contenido como si de una web independiente a la anterior se tratase es necesario crear un directorio dentro del directorio ra\u00edz del servidor web. Debemos a\u00f1adir el siguiente bloque al fichero de configuraci\u00f3n de Nginx . 1 2 3 location / documentacion / { alias / usr / share / nginx / html / documentacion ; } El directorio creado lo hemos denominado documentacion , que se encuentra \"debajo\" del directorio ra\u00edz. Para acceder a esta p\u00e1gina web es necesario introducir en cualquier navegador la direcci\u00f3n ip de la Raspberry y a\u00f1adirle al final /documentacion/ . Con la directiva alias indicamos la ruta absoluta al directorio virtual que hemos creado, de ese modo no ser\u00e1 necesario escribir una direcci\u00f3n \"compleja\" en el navegador.","title":"Documentaci\u00f3n"},{"location":"Lenguaje-de-Marcas/Tipstabet/#recursos","text":"En esta parte del servidor web, indexaremos el contenido que se encuentra en /usr/share/nginx/html/documentacion/Recursos para visualizarlo en el navegador como si de un explorador de archivos se tratase. Se ha a\u00f1adido al fichero de configuraci\u00f3n de Nginx el siguiente bloque: 1 2 3 4 5 6 7 8 location / Recursos / { alias / usr / share / nginx / html / documentacion / Recursos / ; add_before_body / betterlisting / top . html ; add_after_body / betterlisting / bot . html ; autoindex on ; autoindex_localtime on ; autoindex_exact_size off ; } Para que el navegador muestre el contenido de un directorio, \u00fanicamente es necesario establecer la directiva autoindex . Por defecto, la forma en la que se muestra el contenido no es visualmente atractiva, por lo que para darle un aspecto m\u00e1s agradable hemos utilizado el proyecto betterlisting que podemos encontrar en gitlab . Hay varias directivas que no se hab\u00eda visto hasta el momento que explicaremos a continuaci\u00f3n: autoindex_exact_size off: por defecto esta directiva se encuentra activa. Si la desactivamos nos muestra el tama\u00f1o de los ficheros redondeado en KB, MB o GB. add_before_body: nos permite a\u00f1adir contenido antes de cargar el body 1 de la solicitud (el contenido a indexar). add_after_body : a diferencia de la directiva anterior a\u00f1ade contenido despu\u00e9s de cargar el body 1 . Con la dos directivas anteriores conseguimos cambiar el aspecto en el navegador cuando visualizamos el contenido indexado. En estas directivas indicamos la ruta donde se encuentra el contenido a\u00f1adido de betterlisting . Soporta diferentes tipos de ficheros, que podemos encontrar aqu\u00ed . Si queremos a\u00f1adir soporte a nuevos tipos de ficheros, simplemente modificamos el fichero top.html , y a\u00f1adimos el icono con el mismo nombre que el tipo de fichero al directorio icons . Note Si tuvi\u00e9semos ficheros de diferente \u00edndole, y queremos seleccionar cuales son los que el servidor Nginx debe indexar, podr\u00edamos hacer uso del modulo Fancy Index , que nos permite con expresiones regulares seleccionar el contenido a indexar 2 . Para terminar, en la siguiente imagen podemos ver como se encuentra organizado el directorio /usr/share/nginx/html .","title":"Recursos"},{"location":"Lenguaje-de-Marcas/Tipstabet/#fuentes","text":"Creating Virtual Directory Apache Nginx Beginners Guide Nginxconfig.io Apaxy theme El body de la solicitud representa el contenido a indexar. \u21a9 \u21a9 Este modulo no se encuentra disponible para la arquitectura ARM. \u21a9","title":"Fuentes"},{"location":"Planificacion-Administracion-de-Redes/Red/","text":"Redes # Para planificar la organizaci\u00f3n de todos los dispositivos en cuanto a redes se refiere hemos utilizado la herramienta packet tracer de Cisco para crear el mapa l\u00f3gico. El proyecto que estamos llevando a cabo se est\u00e1 realizando en dos aulas, las cuales deben estar correctamente comunicadas, ya que los 4 grupos que conforman el proyecto dispondremos de diferentes dispositivos en cada aula. Mapa l\u00f3gico # En el siguiente esquema l\u00f3gico se puede ver como se estructuran los dispositivos que forman parte del proyecto. Note El mapa l\u00f3gico se puede descargar en formato pdf o pkt . Mapa f\u00edsico # Para la realizaci\u00f3n del mapa f\u00edsico se ha utilizado la herramienta SketchUP . Se ha hecho un peque\u00f1o video que veremos a continuaci\u00f3n en donde aparece la central que se encuentra en Bilbao y la sede localizada en Valencia .","title":"Planificaci\u00f3n de la red"},{"location":"Planificacion-Administracion-de-Redes/Red/#redes","text":"Para planificar la organizaci\u00f3n de todos los dispositivos en cuanto a redes se refiere hemos utilizado la herramienta packet tracer de Cisco para crear el mapa l\u00f3gico. El proyecto que estamos llevando a cabo se est\u00e1 realizando en dos aulas, las cuales deben estar correctamente comunicadas, ya que los 4 grupos que conforman el proyecto dispondremos de diferentes dispositivos en cada aula.","title":"Redes"},{"location":"Planificacion-Administracion-de-Redes/Red/#mapa-logico","text":"En el siguiente esquema l\u00f3gico se puede ver como se estructuran los dispositivos que forman parte del proyecto. Note El mapa l\u00f3gico se puede descargar en formato pdf o pkt .","title":"Mapa l\u00f3gico"},{"location":"Planificacion-Administracion-de-Redes/Red/#mapa-fisico","text":"Para la realizaci\u00f3n del mapa f\u00edsico se ha utilizado la herramienta SketchUP . Se ha hecho un peque\u00f1o video que veremos a continuaci\u00f3n en donde aparece la central que se encuentra en Bilbao y la sede localizada en Valencia .","title":"Mapa f\u00edsico"},{"location":"Sistemas-Operativos/Comandos-de-Administracion/","text":"Comandos de Administraci\u00f3n # Localetctl # Control de la configuraci\u00f3n regional y la configuraci\u00f3n de teclado: 1 2 3 4 5 6 7 8 #Invocar la ayuda localectl -h #Listar la lista de las asignaciones de teclado localectl list-keymaps #Establecer una asignaci\u00f3n de las anteriores listadas localectl set-keymap es Timedatectl # Control de la fecha y hora del sistema: 1 2 3 4 5 6 7 8 #Estado actual timedatectl #Mostrar las zonas horarias disponibles timedatectl list-timezones #Cambiar zona horaria timedatectl set-timezone Europe/Madrid Yum # Gestor de actualizaciones e instalaci\u00f3n de paquetes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #B\u00fasqueda en los respositorios yum list nombre_del_paquete #B\u00fasqueda de paquetes instalados en el sistema yum list installed nombre_del_paquete #Historial de yum yum history #Informaci\u00f3n sobre uno de los \"id\" del historial de yum yum history info id #Deshacer las acciones que corresponden a un \"id\" yum history undo id #Deshacer las acciones correspondientes al \u00faltimo \"id\" yum history undo last Systemctl # Administrador de los servicios en Linux v\u00eda Systemd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #Iniciar un servicio systemctl start nombre_del_servicio #Conocer el estado de un servicio systemctl status nombre_del_servicio #Parar un servicio systemctl stop nombre_del_servicio #Reiniciar un servicio systemctl restart nombre_del_servicio #Habilitar un servicio para que se inicie con el sistema systemctl enable nombre_del_servicio","title":"Comandos de Administraci\u00f3n"},{"location":"Sistemas-Operativos/Comandos-de-Administracion/#comandos-de-administracion","text":"","title":"Comandos de Administraci\u00f3n"},{"location":"Sistemas-Operativos/Comandos-de-Administracion/#localetctl","text":"Control de la configuraci\u00f3n regional y la configuraci\u00f3n de teclado: 1 2 3 4 5 6 7 8 #Invocar la ayuda localectl -h #Listar la lista de las asignaciones de teclado localectl list-keymaps #Establecer una asignaci\u00f3n de las anteriores listadas localectl set-keymap es","title":"Localetctl"},{"location":"Sistemas-Operativos/Comandos-de-Administracion/#timedatectl","text":"Control de la fecha y hora del sistema: 1 2 3 4 5 6 7 8 #Estado actual timedatectl #Mostrar las zonas horarias disponibles timedatectl list-timezones #Cambiar zona horaria timedatectl set-timezone Europe/Madrid","title":"Timedatectl"},{"location":"Sistemas-Operativos/Comandos-de-Administracion/#yum","text":"Gestor de actualizaciones e instalaci\u00f3n de paquetes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #B\u00fasqueda en los respositorios yum list nombre_del_paquete #B\u00fasqueda de paquetes instalados en el sistema yum list installed nombre_del_paquete #Historial de yum yum history #Informaci\u00f3n sobre uno de los \"id\" del historial de yum yum history info id #Deshacer las acciones que corresponden a un \"id\" yum history undo id #Deshacer las acciones correspondientes al \u00faltimo \"id\" yum history undo last","title":"Yum"},{"location":"Sistemas-Operativos/Comandos-de-Administracion/#systemctl","text":"Administrador de los servicios en Linux v\u00eda Systemd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #Iniciar un servicio systemctl start nombre_del_servicio #Conocer el estado de un servicio systemctl status nombre_del_servicio #Parar un servicio systemctl stop nombre_del_servicio #Reiniciar un servicio systemctl restart nombre_del_servicio #Habilitar un servicio para que se inicie con el sistema systemctl enable nombre_del_servicio","title":"Systemctl"},{"location":"Sistemas-Operativos/Equipos-Clientes/Acceso-Remoto/","text":"Acceso remoto # Al igual que en la creaci\u00f3n del punto de restauraci\u00f3n, debemos ejecutar una vez que se haya abierto la ventana de ejecutar sysdm.cpl . Se abrir\u00e1 la venta de \"Propiedades del sistema\" , donde deberemos seleccionar la pesta\u00f1a de acceso remoto. En la parte inferior deberemos permitir las conexiones remotas","title":"Acceso Remoto"},{"location":"Sistemas-Operativos/Equipos-Clientes/Acceso-Remoto/#acceso-remoto","text":"Al igual que en la creaci\u00f3n del punto de restauraci\u00f3n, debemos ejecutar una vez que se haya abierto la ventana de ejecutar sysdm.cpl . Se abrir\u00e1 la venta de \"Propiedades del sistema\" , donde deberemos seleccionar la pesta\u00f1a de acceso remoto. En la parte inferior deberemos permitir las conexiones remotas","title":"Acceso remoto"},{"location":"Sistemas-Operativos/Equipos-Clientes/Dominio-linux/","text":"CentOS en Windows Server 2012 # Configuraci\u00f3n m\u00e1quina CentOS 7 # Para llevar a cabo el proceso, utilizaremos la herramienta PowerBroker que nos proporciona la empresa Beyond trust . Antes de unir al controlador de dominio la m\u00e1quina Linux que tenemos, debemos realizar una serie de cambios. En primer lugar modificaremos el fichero /etc/sysconfig/network-script/ifcfg-enp3s0 . El fichero quedar\u00e1 del siguiente modo: 1 2 3 4 5 6 7 8 9 DEVICE = enp3s0 ONBOOT = yes BOOTPROTO = static IPADDR = 172 .16.43.225 NETMASK = 255 .255.255.0 GATEWAY = 172 .16.43.254 DNS1 = 172 .16.43.221 #Direcci\u00f3n IP de Windows Server DNS2 = 8 .8.8.8 DOMAIN = tipstabet.local #Nombre de dominio de nuestro Windows Server El siguiente paso ser\u00e1 deshabilitar selinux que podemos encontrarlo en la ruta /etc/sysconfig/selinux , tal y como se explic\u00f3 aqu\u00ed . Continuamos realizando cambios en el fichero /etc/hosts y /etc/hostname . En el primer fichero de los dos debemos a\u00f1adir una l\u00ednea con la direcci\u00f3n ip del servidor junto a su nombre de dominio . \u00bfPor qu\u00e9 debemos modificar el hostname? Para poder unir al controlador del dominio mediante la herramienta PowerBroker, es necesario que el nombre de nuestra m\u00e1quina sea diferente a \"linux\" o \"localhost\". Podemos cambiar el nombre editando el fichero /etc/hostname o mediante el comando hostnamectl . Modificando el fichero: 1 vi /etc/hostname Comando hostnamectl : 1 2 3 4 5 6 7 8 #Modificamos el nombre de la m\u00e1quina hostnamectl set-hostname centos7 --static #Reiniciamos el servicio systemctl restart systemd-hostnamed #Comprobamos que se ha modificado correctamente hosntamectl status Instalaci\u00f3n PowerBroker # Para realizar la instalaci\u00f3n de PowerBroker hemos seguido la gu\u00eda que podemos encontrar en su web. A\u00f1adimos los repositorios PBISO 1 sudo wget -O /etc/yum.repos.d/pbiso.repo http://repo.pbis.beyondtrust.com/yum/pbiso.repo Eliminamos la cach\u00e9 de yum 1 yum clean all Instalamos \"pbis-open\" 1 yum install pbis-opne A\u00f1adiendo CentOS7 a Windows Server # Una vez que ya hemos llegado hasta aqu\u00ed, \u00fanicamente nos queda introducir un comando para a\u00f1adir la m\u00e1quina nuestro Servidor Windows. El comando a ejecutar es el siguiente: 1 2 3 domainjoin-cli join tipstabet.local #Si no indicamos usuario nos los solicitar\u00e1 domainjoin-cli join tipstabet.local administrador Por \u00faltimo, comprobamos en el Servidor de Windows que la m\u00e1quina se ha unido correctamente al dominio. Fuentes # Unir CentOS7 a Windows Server 2012 Change hostname CentOS7 Modificar archivos hosts","title":"Unir Linux a Windows Server"},{"location":"Sistemas-Operativos/Equipos-Clientes/Dominio-linux/#centos-en-windows-server-2012","text":"","title":"CentOS en Windows Server 2012"},{"location":"Sistemas-Operativos/Equipos-Clientes/Dominio-linux/#configuracion-maquina-centos-7","text":"Para llevar a cabo el proceso, utilizaremos la herramienta PowerBroker que nos proporciona la empresa Beyond trust . Antes de unir al controlador de dominio la m\u00e1quina Linux que tenemos, debemos realizar una serie de cambios. En primer lugar modificaremos el fichero /etc/sysconfig/network-script/ifcfg-enp3s0 . El fichero quedar\u00e1 del siguiente modo: 1 2 3 4 5 6 7 8 9 DEVICE = enp3s0 ONBOOT = yes BOOTPROTO = static IPADDR = 172 .16.43.225 NETMASK = 255 .255.255.0 GATEWAY = 172 .16.43.254 DNS1 = 172 .16.43.221 #Direcci\u00f3n IP de Windows Server DNS2 = 8 .8.8.8 DOMAIN = tipstabet.local #Nombre de dominio de nuestro Windows Server El siguiente paso ser\u00e1 deshabilitar selinux que podemos encontrarlo en la ruta /etc/sysconfig/selinux , tal y como se explic\u00f3 aqu\u00ed . Continuamos realizando cambios en el fichero /etc/hosts y /etc/hostname . En el primer fichero de los dos debemos a\u00f1adir una l\u00ednea con la direcci\u00f3n ip del servidor junto a su nombre de dominio . \u00bfPor qu\u00e9 debemos modificar el hostname? Para poder unir al controlador del dominio mediante la herramienta PowerBroker, es necesario que el nombre de nuestra m\u00e1quina sea diferente a \"linux\" o \"localhost\". Podemos cambiar el nombre editando el fichero /etc/hostname o mediante el comando hostnamectl . Modificando el fichero: 1 vi /etc/hostname Comando hostnamectl : 1 2 3 4 5 6 7 8 #Modificamos el nombre de la m\u00e1quina hostnamectl set-hostname centos7 --static #Reiniciamos el servicio systemctl restart systemd-hostnamed #Comprobamos que se ha modificado correctamente hosntamectl status","title":"Configuraci\u00f3n m\u00e1quina CentOS 7"},{"location":"Sistemas-Operativos/Equipos-Clientes/Dominio-linux/#instalacion-powerbroker","text":"Para realizar la instalaci\u00f3n de PowerBroker hemos seguido la gu\u00eda que podemos encontrar en su web. A\u00f1adimos los repositorios PBISO 1 sudo wget -O /etc/yum.repos.d/pbiso.repo http://repo.pbis.beyondtrust.com/yum/pbiso.repo Eliminamos la cach\u00e9 de yum 1 yum clean all Instalamos \"pbis-open\" 1 yum install pbis-opne","title":"Instalaci\u00f3n PowerBroker"},{"location":"Sistemas-Operativos/Equipos-Clientes/Dominio-linux/#anadiendo-centos7-a-windows-server","text":"Una vez que ya hemos llegado hasta aqu\u00ed, \u00fanicamente nos queda introducir un comando para a\u00f1adir la m\u00e1quina nuestro Servidor Windows. El comando a ejecutar es el siguiente: 1 2 3 domainjoin-cli join tipstabet.local #Si no indicamos usuario nos los solicitar\u00e1 domainjoin-cli join tipstabet.local administrador Por \u00faltimo, comprobamos en el Servidor de Windows que la m\u00e1quina se ha unido correctamente al dominio.","title":"A\u00f1adiendo CentOS7 a Windows Server"},{"location":"Sistemas-Operativos/Equipos-Clientes/Dominio-linux/#fuentes","text":"Unir CentOS7 a Windows Server 2012 Change hostname CentOS7 Modificar archivos hosts","title":"Fuentes"},{"location":"Sistemas-Operativos/Equipos-Clientes/Imagenes-del-Sistema/","text":"Imagenes del sistema # Para aprovechar las cualidades del NAS como dispositivo de almacenamiento en red, ser\u00e1 el destino de las im\u00e1genes del sistema de los diferentes dispositivos. Para ello hemos creado una carpeta compartida ( aqu\u00ed podemos encontrar una peque\u00f1a gu\u00eda del proceso necesario a seguir). Los par\u00e1metros m\u00e1s importantes de la captura anterior son los siguientes: Share: es el directorio que deseamos compartir. Browseable: listar o no como recurso de red, es decir que para acceder al recurso es necesario conocer la ruta completa. Guest ok: habilita el acceso a usuario no autenticados. Read only : permitir la escritura o no. Una vez que ya tenemos compartido el directorio debemos configurar nuestros equipos Windows para que la imagen que hagamos del sistema se realice en el NAS. En primer lugar debemos abrir el Panel de control e ir a la ruta Panel de control > Sistema y seguridad > Copias de seguridad y restauraci\u00f3n. En el panel lateral que nos aparece, debemos seleccionar \"Crear una imagen de sistema\" . Abrimos la ventana de configuraci\u00f3n, y debemos seguir las siguientes indicaciones: Seleccionar ubicaci\u00f3n de red como lugar de almacenamiento. En la siguiente pantalla debemos completar los datos que nos solicita, tal y como se ve en la siguiente captura. Cuando pulsamos \"aceptar\" , Windows realiza una validaci\u00f3n de la ubicaci\u00f3n de red. Cuando se completa la validaci\u00f3n pasamos al resumen de las unidades sobre las que se realizar\u00e1 la imagen del sistema. Hemos llegado al paso final, dependiendo del tama\u00f1o de la copia se demorar\u00e1 en el tiempo, ya que la copia se hace a trav\u00e9s de la red y no en un dispositivo conectado directamente al equipo.","title":"Imagen del Sistema"},{"location":"Sistemas-Operativos/Equipos-Clientes/Imagenes-del-Sistema/#imagenes-del-sistema","text":"Para aprovechar las cualidades del NAS como dispositivo de almacenamiento en red, ser\u00e1 el destino de las im\u00e1genes del sistema de los diferentes dispositivos. Para ello hemos creado una carpeta compartida ( aqu\u00ed podemos encontrar una peque\u00f1a gu\u00eda del proceso necesario a seguir). Los par\u00e1metros m\u00e1s importantes de la captura anterior son los siguientes: Share: es el directorio que deseamos compartir. Browseable: listar o no como recurso de red, es decir que para acceder al recurso es necesario conocer la ruta completa. Guest ok: habilita el acceso a usuario no autenticados. Read only : permitir la escritura o no. Una vez que ya tenemos compartido el directorio debemos configurar nuestros equipos Windows para que la imagen que hagamos del sistema se realice en el NAS. En primer lugar debemos abrir el Panel de control e ir a la ruta Panel de control > Sistema y seguridad > Copias de seguridad y restauraci\u00f3n. En el panel lateral que nos aparece, debemos seleccionar \"Crear una imagen de sistema\" . Abrimos la ventana de configuraci\u00f3n, y debemos seguir las siguientes indicaciones: Seleccionar ubicaci\u00f3n de red como lugar de almacenamiento. En la siguiente pantalla debemos completar los datos que nos solicita, tal y como se ve en la siguiente captura. Cuando pulsamos \"aceptar\" , Windows realiza una validaci\u00f3n de la ubicaci\u00f3n de red. Cuando se completa la validaci\u00f3n pasamos al resumen de las unidades sobre las que se realizar\u00e1 la imagen del sistema. Hemos llegado al paso final, dependiendo del tama\u00f1o de la copia se demorar\u00e1 en el tiempo, ya que la copia se hace a trav\u00e9s de la red y no en un dispositivo conectado directamente al equipo.","title":"Imagenes del sistema"},{"location":"Sistemas-Operativos/Equipos-Clientes/Punto-de-Restauracion/","text":"Punto de Restauraci\u00f3n # \u00bfCu\u00e1l es la principal utilidad de los puntos de restauraci\u00f3n? La utilidad principal es poder recuperar el sistema a un estado anterior, principalmente cuando debido a una actualizaci\u00f3n o instalaci\u00f3n de una aplicaci\u00f3n el sistema no funciona correctamente. Este sistema excluye lo referente a los archivos almacenados. La utilidad de esta herramienta es poder retornar el equipo a un estado anterior, incluyendo el sistema operativo y las aplicaciones instaladas. En primer lugar abrimos la ventana de \"ejecutar\" pulsando la combinaci\u00f3n de telcado Windows + R . En la ventana que se abre debemos escribir sysdm.cpl para abrir las Propiedades del sistema. En la ventana de Propiedades del sistema debemos seleccionar la pesta\u00f1a de Protecci\u00f3n del sistema . Debemos pulsar el bot\u00f3n de configurar para poder activar y configurar el espacio que usaremos en disco. En nuestro caso la configuraci\u00f3n es la siguiente: Si deseamos restaurar un punto de restauraci\u00f3n o consultar los diferentes punto que tenemos creados, debemos abrir la ventana de Restaurar sistema .","title":"Punto de restauraci\u00f3n"},{"location":"Sistemas-Operativos/Equipos-Clientes/Punto-de-Restauracion/#punto-de-restauracion","text":"\u00bfCu\u00e1l es la principal utilidad de los puntos de restauraci\u00f3n? La utilidad principal es poder recuperar el sistema a un estado anterior, principalmente cuando debido a una actualizaci\u00f3n o instalaci\u00f3n de una aplicaci\u00f3n el sistema no funciona correctamente. Este sistema excluye lo referente a los archivos almacenados. La utilidad de esta herramienta es poder retornar el equipo a un estado anterior, incluyendo el sistema operativo y las aplicaciones instaladas. En primer lugar abrimos la ventana de \"ejecutar\" pulsando la combinaci\u00f3n de telcado Windows + R . En la ventana que se abre debemos escribir sysdm.cpl para abrir las Propiedades del sistema. En la ventana de Propiedades del sistema debemos seleccionar la pesta\u00f1a de Protecci\u00f3n del sistema . Debemos pulsar el bot\u00f3n de configurar para poder activar y configurar el espacio que usaremos en disco. En nuestro caso la configuraci\u00f3n es la siguiente: Si deseamos restaurar un punto de restauraci\u00f3n o consultar los diferentes punto que tenemos creados, debemos abrir la ventana de Restaurar sistema .","title":"Punto de Restauraci\u00f3n"}]}